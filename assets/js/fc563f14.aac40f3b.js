"use strict";(self.webpackChunkdiscord4j_documentation=self.webpackChunkdiscord4j_documentation||[]).push([[227],{7198:(e,r,i)=>{i.r(r),i.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>n,metadata:()=>a,toc:()=>c});var t=i(4848),s=i(8453);const n={id:"reactive-reactor-tutorial",title:"Reactive (Reactor) Tutorial",sidebar_label:"Reactive (Reactor) Tutorial",slug:"/reactive-reactor-tutorial"},o=void 0,a={id:"Conceptual Guides/reactive-reactor-tutorial",title:"Reactive (Reactor) Tutorial",description:"Introduction",source:"@site/docs/06-Conceptual Guides/reactive-reactor-tutorial.mdx",sourceDirName:"06-Conceptual Guides",slug:"/reactive-reactor-tutorial",permalink:"/reactive-reactor-tutorial",draft:!1,unlisted:!1,editUrl:"https://github.com/Discord4J/documentation/edit/master/docs/06-Conceptual Guides/reactive-reactor-tutorial.mdx",tags:[],version:"current",lastUpdatedAt:1632887579e3,frontMatter:{id:"reactive-reactor-tutorial",title:"Reactive (Reactor) Tutorial",sidebar_label:"Reactive (Reactor) Tutorial",slug:"/reactive-reactor-tutorial"},sidebar:"mySidebar",previous:{title:"Lambda Tutorial",permalink:"/lambda-tutorial"},next:{title:"Migrating from v2.x to v3.1",permalink:"/migrating-from-v2-x-to-v3-1"}},l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Reactor Basics",id:"reactor-basics",level:2},{value:"Publisher",id:"publisher",level:3},{value:"Subscriber",id:"subscriber",level:3},{value:"Subscription",id:"subscription",level:3},{value:"Mono",id:"mono",level:3},{value:"Flux",id:"flux",level:3},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Basic Chaining (<code>map</code>, <code>flatMap</code>, <code>filter</code>, <code>filterWhen</code>)",id:"basic-chaining-map-flatmap-filter-filterwhen",level:3},{value:"<code>map</code>",id:"map",level:4},{value:"<code>flatMap</code>",id:"flatmap",level:4},{value:"<code>filter</code>",id:"filter",level:4},{value:"<code>filterWhen</code>",id:"filterwhen",level:4}];function d(e){const r={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)(r.p,{children:["Discord4J uses ",(0,t.jsx)(r.a,{href:"https://projectreactor.io/",children:"Reactor"})," as the implementation of ",(0,t.jsx)(r.a,{href:"http://www.reactive-streams.org/",children:"reactive-streams"})," which follows ",(0,t.jsx)(r.a,{href:"https://www.reactivemanifesto.org/",children:"The Reactive Manifesto"}),"."]}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Reactive_programming",children:"Reactive programming"}),' is a programming paradigm where data is expressed in "streams" and changes to these "streams" is propagated downwards (or "downstream"). This is achieved with a ',(0,t.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/Declarative_programming",children:"declarative"})," style of programming, where the programmer builds the structure of the program that dictates logic, rather than handling its control flow directly. A very popular implementation of declarative programming is ",(0,t.jsx)(r.a,{href:"https://en.wikipedia.org/wiki/SQL",children:"SQL"})," and in Java declarative programs can be easily achieved using ",(0,t.jsx)(r.a,{href:"/lambda-tutorial",children:"lambdas"}),"."]}),"\n",(0,t.jsx)(r.h2,{id:"reactor-basics",children:"Reactor Basics"}),"\n",(0,t.jsxs)(r.p,{children:["You can view Reactor as simply an implementation of reactive programming in Java. While Java does provide mechanisms for better delegation of ",(0,t.jsx)(r.em,{children:"work"})," (",(0,t.jsx)(r.code,{children:"ForkJoin"}),"), this is unnecessarily complicated and does not provide nearly as much utility and robustness as Reactor."]}),"\n",(0,t.jsx)(r.h3,{id:"publisher",children:"Publisher"}),"\n",(0,t.jsxs)(r.p,{children:["A ",(0,t.jsx)(r.code,{children:"Publisher"})," is actually a ",(0,t.jsx)(r.code,{children:"reactive-streams"})," concept, and is even part of the ",(0,t.jsx)(r.a,{href:"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.Publisher.html",children:"Flow API"}),". In short, a ",(0,t.jsx)(r.code,{children:"Publisher"})," ",(0,t.jsx)(r.em,{children:"publishes"}),' data to a stream. In Discord, the "publisher" is Discord itself; they "publish" or "push" data to users and acts as a ',(0,t.jsx)(r.em,{children:"source"})," of data. All data begins with a ",(0,t.jsx)(r.code,{children:"Publisher"}),"."]}),"\n",(0,t.jsx)(r.h3,{id:"subscriber",children:"Subscriber"}),"\n",(0,t.jsxs)(r.p,{children:["A ",(0,t.jsx)(r.code,{children:"Subscriber"})," is also a ",(0,t.jsx)(r.code,{children:"reactive-streams"})," concept, and is also part of the ",(0,t.jsx)(r.a,{href:"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.Subscriber.html",children:"Flow API"}),". A ",(0,t.jsx)(r.code,{children:"Subscriber"}),' "subscribes" or "consumes" data from a stream. In Discord, the "subscriber" is us, the users; we take the data ',(0,t.jsx)(r.em,{children:"published"})," to us from Discord and process it in a way to monitor activity or respond in some fashion. All data ends at a ",(0,t.jsx)(r.code,{children:"Subscriber"}),"."]}),"\n",(0,t.jsx)(r.h3,{id:"subscription",children:"Subscription"}),"\n",(0,t.jsxs)(r.p,{children:["A ",(0,t.jsx)(r.code,{children:"reactive-streams"})," concept and part of the ",(0,t.jsx)(r.a,{href:"https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.Subscription.html",children:"Flow API"})," a ",(0,t.jsx)(r.code,{children:"Subscription"})," describes a link between a ",(0,t.jsx)(r.code,{children:"Publisher"})," and a ",(0,t.jsx)(r.code,{children:"Subscriber"}),". A ",(0,t.jsx)(r.code,{children:"Subscriber"})," ",(0,t.jsx)(r.em,{children:"requests"})," data from a ",(0,t.jsx)(r.code,{children:"Publisher"})," and the amount of data the ",(0,t.jsx)(r.code,{children:"Publisher"})," ",(0,t.jsx)(r.em,{children:"pushes"})," to the ",(0,t.jsx)(r.code,{children:"Subscriber"})," is dependent on how much data the ",(0,t.jsx)(r.code,{children:"Subscriber"})," requested. Additionally, the ",(0,t.jsx)(r.code,{children:"Subscriber"})," can cancel the ",(0,t.jsx)(r.code,{children:"Subscription"})," at any time."]}),"\n",(0,t.jsxs)(r.p,{children:["While you as a programmer using Reactor will not see ",(0,t.jsx)(r.code,{children:"Subscription"})," often, it is useful to know how data flows from a ",(0,t.jsx)(r.code,{children:"Publisher"})," to a ",(0,t.jsx)(r.code,{children:"Subscriber"}),". Without a ",(0,t.jsx)(r.code,{children:"Subscription"}),", data is never ",(0,t.jsx)(r.em,{children:"requested"}),", thus data never ",(0,t.jsx)(r.em,{children:"flows"})," from a ",(0,t.jsx)(r.code,{children:"Publisher"})," to a ",(0,t.jsx)(r.code,{children:"Subscriber"}),"."]}),"\n",(0,t.jsx)(r.h3,{id:"mono",children:"Mono"}),"\n",(0,t.jsxs)(r.p,{children:["A ",(0,t.jsx)(r.a,{href:"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html",children:"Mono"})," represents a stream of data that either has an element, or not. It is the reactive equivalent of an ",(0,t.jsx)(r.a,{href:"https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html",children:"Optional"}),". Since ",(0,t.jsx)(r.code,{children:"Mono"}),' is a "provider", or a "source" of data, it is also an implementation of ',(0,t.jsx)(r.code,{children:"Publisher"}),"."]}),"\n",(0,t.jsx)(r.h3,{id:"flux",children:"Flux"}),"\n",(0,t.jsxs)(r.p,{children:["A ",(0,t.jsx)(r.a,{href:"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html",children:"Flux"})," represents a stream of possibly unlimited data. It is the reactive equivalent of a ",(0,t.jsx)(r.a,{href:"https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html",children:"Stream"}),". Since ",(0,t.jsx)(r.code,{children:"Flux"}),' is a "provider", or a "source" of data, it is also an implementation of ',(0,t.jsx)(r.code,{children:"Publisher"}),"."]}),"\n",(0,t.jsx)(r.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,t.jsx)(r.p,{children:'Let\'s print a simple "Hello World" reactively.'}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:"Mono.just(\"Hello World\").subscribe(System.out::println);\r\n// or\r\nFlux.just('H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '\\n')\r\n    .subscribe(System.out::print);\n"})}),"\n",(0,t.jsx)(r.p,{children:"Breaking down the first line:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["We create a ",(0,t.jsx)(r.code,{children:"Mono"})," that will have a single element, a String ",(0,t.jsx)(r.code,{children:"Hello World"}),"."]}),"\n",(0,t.jsxs)(r.li,{children:["We ",(0,t.jsx)(r.em,{children:"subscribe"})," to this data, which creates a ",(0,t.jsx)(r.code,{children:"Subscription"})," (that implicitly requests data from the ",(0,t.jsx)(r.code,{children:"Publisher"})," (",(0,t.jsx)(r.code,{children:"Mono"})," in this case)), which allows the data to flow to our ",(0,t.jsx)(r.code,{children:"System.out::println"})," method reference which consumes the data."]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"Breaking down the second line:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["We create a ",(0,t.jsx)(r.code,{children:"Flux"}),' that will have multiple elements that eventually spell out the String "Hello World" with a newline character.']}),"\n",(0,t.jsxs)(r.li,{children:["We ",(0,t.jsx)(r.em,{children:"subscribe"})," to this data, which creates a ",(0,t.jsx)(r.code,{children:"Subscription"})," (that implicitly requests data from the ",(0,t.jsx)(r.code,{children:"Publisher"})," (",(0,t.jsx)(r.code,{children:"Flux"})," in this case), which allows the data to flow to our ",(0,t.jsx)(r.code,{children:"System.out::print"})," method reference which consumes the data."]}),"\n"]}),"\n",(0,t.jsx)(r.p,{children:"It is important to note two characteristics about these two examples:"}),"\n",(0,t.jsxs)(r.ol,{children:["\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:'Flux.just("Hello World").subscribe(System.out::println);'})," is a just as valid example for ",(0,t.jsx)(r.code,{children:"Flux"}),". ",(0,t.jsx)(r.code,{children:"Flux"})," can represent a possibly infinite amount of data; this can be as small as no elements, one element, two elements, or a billion elements; it does not matter. Reactor provides ",(0,t.jsx)(r.code,{children:"Mono"}),' as a simple way to express "at most one element" similar to how ',(0,t.jsx)(r.code,{children:"Optional"}),' can be seen as a simple way to express "an element exists or not" compared to ',(0,t.jsx)(r.code,{children:"Stream"}),". So even if you know you're only going to have at most one element, you ",(0,t.jsx)(r.em,{children:"can"})," use ",(0,t.jsx)(r.code,{children:"Flux"}),", but it is better to use ",(0,t.jsx)(r.code,{children:"Mono"})," instead."]}),"\n"]}),"\n",(0,t.jsxs)(r.li,{children:["\n",(0,t.jsxs)(r.p,{children:["Both examples require a call to ",(0,t.jsx)(r.code,{children:"subscribe"}),". Without any ",(0,t.jsx)(r.code,{children:"subscribe"}),", no ",(0,t.jsx)(r.code,{children:"Subscription"})," is created, thus data is never requested from a ",(0,t.jsx)(r.code,{children:"Publisher"}),", thus data will never flow. The use of ",(0,t.jsx)(r.code,{children:"subscribe"})," is critical and without it our program will simply do nothing."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(r.h3,{id:"basic-chaining-map-flatmap-filter-filterwhen",children:["Basic Chaining (",(0,t.jsx)(r.code,{children:"map"}),", ",(0,t.jsx)(r.code,{children:"flatMap"}),", ",(0,t.jsx)(r.code,{children:"filter"}),", ",(0,t.jsx)(r.code,{children:"filterWhen"}),")"]}),"\n",(0,t.jsxs)(r.p,{children:["Reactor has ",(0,t.jsx)(r.em,{children:"many"}),' methods (commonly referred to as "operations" or "ops") that allow programmers to manipulate the data to their content. The idea of combining multiple ops together is a form of "chaining". It should be an ultimate goal with Reactor to only express reactive operations as "chains".']}),"\n",(0,t.jsx)(r.h4,{id:"map",children:(0,t.jsx)(r.code,{children:"map"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"map"})," is a transformation of a data type ",(0,t.jsx)(r.code,{children:"T"})," to some other data type ",(0,t.jsx)(r.code,{children:"U"}),". For example:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'Mono.just("Hello World")\r\n    .map(String::length)\r\n    .subscribe(System.out::println); // prints 11\r\nFlux.just("Hello", "World")\r\n    .map(String::length)\r\n    .subscribe(System.out::println) // prints 5 then 5\n'})}),"\n",(0,t.jsxs)(r.p,{children:["Both examples transform a data type of ",(0,t.jsx)(r.code,{children:"String"})," to another data type of ",(0,t.jsx)(r.code,{children:"Integer"}),", by using ",(0,t.jsx)(r.code,{children:"String::length"}),"."]}),"\n",(0,t.jsx)(r.h4,{id:"flatmap",children:(0,t.jsx)(r.code,{children:"flatMap"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"flatMap"})," is a transformation of a data type ",(0,t.jsx)(r.code,{children:"T"})," to some other data type ",(0,t.jsx)(r.code,{children:"U"})," that is wrapped in some ",(0,t.jsx)(r.code,{children:"Mono"})," or ",(0,t.jsx)(r.code,{children:"Publisher"})," depending on the original source (so ",(0,t.jsx)(r.code,{children:"Mono<U>"})," or ",(0,t.jsx)(r.code,{children:"Publisher<U>"}),"). For example:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'Mono.just("Hello World")\r\n    .flatMap(aString -> Mono.just(aString.length()))\r\n    .subscribe(System.out::println); // prints 11\r\nFlux.just("Hello", "World")\r\n    .flatMap(aString -> Flux.just(aString.length(), 42))\r\n    .subscribe(System.out::println); // prints 5 then 42 then 5 then 42\n'})}),"\n",(0,t.jsxs)(r.p,{children:["Both examples transform a data type of ",(0,t.jsx)(r.code,{children:"String"})," to another data type of ",(0,t.jsx)(r.code,{children:"Integer"}),", but the source of the ",(0,t.jsx)(r.code,{children:"Integer"})," is coming from some other reactive type. Every time data passes through a ",(0,t.jsx)(r.code,{children:"flatMap"})," the inner ",(0,t.jsx)(r.code,{children:"Publisher"}),' is resubscribed, which means data is in essence "restarted" on each invocation.']}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"Mono"}),"'s ",(0,t.jsx)(r.code,{children:"flatMap"})," only supports a source coming from another ",(0,t.jsx)(r.code,{children:"Mono"}),", while ",(0,t.jsx)(r.code,{children:"Flux"})," supports any ",(0,t.jsx)(r.code,{children:"Publisher"}),"."]}),"\n",(0,t.jsx)(r.h4,{id:"filter",children:(0,t.jsx)(r.code,{children:"filter"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"filter"})," prevents items from continuing to flow downstream if it fails a supplied ",(0,t.jsx)(r.a,{href:"https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html",children:"Predicate"}),". For example:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'Mono.just("Hello World")\r\n    .filter(aString -> aString.equals("Hello"))\r\n    .subscribe(System.out::println); // prints nothing\r\nFlux.just("Hello", "World")\r\n    .filter(aString -> aString.equals("Hello"))\r\n    .subscribe(System.out::println) // prints "Hello"\n'})}),"\n",(0,t.jsxs)(r.p,{children:["Both examples are ",(0,t.jsx)(r.em,{children:"filtering"})," out items which do ",(0,t.jsx)(r.strong,{children:"NOT"}),' equal "Hello".']}),"\n",(0,t.jsxs)(r.p,{children:["For the ",(0,t.jsx)(r.code,{children:"Mono"}),' example, since the only element is "Hello World", which does ',(0,t.jsx)(r.strong,{children:"NOT"}),' equal "Hello", then it is filtered out, thus nothing prints. It is important to note that data ',(0,t.jsx)(r.em,{children:"did"})," flow, it just got filtered out in the end, resulting in an ",(0,t.jsx)(r.em,{children:"empty"})," ",(0,t.jsx)(r.code,{children:"Mono"}),'. The concept of "emptiness" will be explained a bit later.']}),"\n",(0,t.jsxs)(r.p,{children:["For the ",(0,t.jsx)(r.code,{children:"Flux"}),' example, since "World" does ',(0,t.jsx)(r.strong,{children:"NOT"}),' equal "Hello", it was ',(0,t.jsx)(r.em,{children:"filtered"}),' out of the stream, thus, only "Hello" remained which resulted in the only thing being printed.']}),"\n",(0,t.jsx)(r.h4,{id:"filterwhen",children:(0,t.jsx)(r.code,{children:"filterWhen"})}),"\n",(0,t.jsxs)(r.p,{children:[(0,t.jsx)(r.code,{children:"filterWhen"})," is to ",(0,t.jsx)(r.code,{children:"filter"})," as ",(0,t.jsx)(r.code,{children:"flatMap"})," is to ",(0,t.jsx)(r.code,{children:"map"}),". Rather than a ",(0,t.jsx)(r.code,{children:"Predicate"}),", which is essentially a transformation from a type ",(0,t.jsx)(r.code,{children:"T"})," to a ",(0,t.jsx)(r.code,{children:"boolean"}),", ",(0,t.jsx)(r.code,{children:"filterWhen"})," expects a transformation of type ",(0,t.jsx)(r.code,{children:"T"})," to some ",(0,t.jsx)(r.code,{children:"Publisher<Boolean>"}),", which will decide whether data should continue to flow downstream. For example:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-java",children:'Mono.just("Hello World")\r\n    .filterWhen(aString -> Mono.just(aString.equals("Hello")))\r\n    .subscribe(System.out::println); // prints nothing\r\nFlux.just("Hello", "World")\r\n    .filterWhen(aString -> Mono.just(aString.equals("Hello")))\r\n    .subscribe(System.out::println); // prints "Hello"\n'})}),"\n",(0,t.jsxs)(r.p,{children:["Similar to ",(0,t.jsx)(r.code,{children:"flatMap"}),", as data passes through the ",(0,t.jsx)(r.code,{children:"filterWhen"}),", the ",(0,t.jsx)(r.code,{children:"Publisher"})," is resubscribed."]})]})}function h(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,r,i)=>{i.d(r,{R:()=>o,x:()=>a});var t=i(6540);const s={},n=t.createContext(s);function o(e){const r=t.useContext(n);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(n.Provider,{value:r},e.children)}}}]);