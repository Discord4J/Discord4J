"use strict";(self.webpackChunkdiscord4j_documentation=self.webpackChunkdiscord4j_documentation||[]).push([[499],{5390:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var i=t(4848),o=t(8453);const s={id:"basic-bot-tutorial",title:"Basic Bot Tutorial",sidebar_label:"Basic Bot Tutorial",slug:"/basic-bot-tutorial"},a=void 0,r={id:"Tutorials/basic-bot-tutorial",title:"Basic Bot Tutorial",description:"Making your first bot is very simple. This tutorial will walk you through how to make a basic bot that responds to a",source:"@site/docs/03-Tutorials/02-basic-bot-tutorial.mdx",sourceDirName:"03-Tutorials",slug:"/basic-bot-tutorial",permalink:"/basic-bot-tutorial",draft:!1,unlisted:!1,editUrl:"https://github.com/Discord4J/documentation/edit/master/docs/03-Tutorials/02-basic-bot-tutorial.mdx",tags:[],version:"current",lastUpdatedAt:1712939318e3,sidebarPosition:2,frontMatter:{id:"basic-bot-tutorial",title:"Basic Bot Tutorial",sidebar_label:"Basic Bot Tutorial",slug:"/basic-bot-tutorial"},sidebar:"mySidebar",previous:{title:"Creating a Discord Application",permalink:"/discord-application-tutorial"},next:{title:"Music Bot Tutorial",permalink:"/music-bot-tutorial"}},l={},c=[{value:"What is a bot?",id:"what-is-a-bot",level:2},{value:"Download / Install",id:"download--install",level:2},{value:"IntelliJ",id:"intellij",level:3},{value:"Eclipse",id:"eclipse",level:3},{value:"Constructing the client",id:"constructing-the-client",level:2},{value:"Logging In",id:"logging-in",level:2},{value:"Responding to events",id:"responding-to-events",level:2},{value:"ReadyEvent",id:"readyevent",level:3},{value:"MessageCreateEvent",id:"messagecreateevent",level:3},{value:"Multiple Events",id:"multiple-events",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Making your first bot is very simple. This tutorial will walk you through how to make a basic bot that responds to a\r\nping command and listens to some other events."}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["This tutorial assumes a basic familiarity with reactive programming and Reactor. Refer to\r\n",(0,i.jsx)(n.a,{href:"/reactive-reactor-tutorial",children:"Reactive (Reactor) Tutorial"})," for information on that topic."]})}),"\n",(0,i.jsx)(n.h2,{id:"what-is-a-bot",children:"What is a bot?"}),"\n",(0,i.jsx)(n.p,{children:"But first, it will be helpful to understand roughly how Discord bots work."}),"\n",(0,i.jsx)(n.p,{children:'A "bot" is simply a program running on a computer that can interact with Discord. Discord4J provides a way to do those\r\ninteractions in Java. We take care of the low-level details like maintaining a websocket connection and making HTTP\r\nrequests to Discord\'s web API.'}),"\n",(0,i.jsx)(n.p,{children:'When "logged in," a bot has an active websocket connection with Discord, which will send events to the bot. For example,\r\nwhen a message gets sent in a channel the bot has access to, Discord will notify the bot by sending an event with all\r\nof the relevant information about the message. The bot can interact with Discord primarily by making HTTP requests. For\r\nexample, that is how the bot can send a message.'}),"\n",(0,i.jsx)(n.p,{children:'Using just those two mechanisms (receiving events from Discord via a websocket, and interacting with Discord via HTTP),\r\nyou can create complex programs that do all sorts of things in Discord. In this tutorial, you will learn how to create\r\na very simple, but extensible, bot which will send the message "Pong!" any time someone sends "!ping".'}),"\n",(0,i.jsx)(n.h2,{id:"download--install",children:"Download / Install"}),"\n",(0,i.jsxs)(n.p,{children:["You first need to set up a project with Discord4J as a dependency. Refer to the ",(0,i.jsx)(n.a,{href:"/quickstart",children:"Quickstart"})," page for\r\ndetails on how to do that with Maven or Gradle. If you're unfamiliar with those tools, refer to the documentation for\r\nyour specific IDE."]}),"\n",(0,i.jsx)(n.h3,{id:"intellij",children:"IntelliJ"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.jetbrains.com/help/idea/getting-started-with-gradle.html",children:"IntelliJ / Gradle"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://www.jetbrains.com/help/idea/maven-support.html",children:"IntelliJ / Maven"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"eclipse",children:"Eclipse"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"http://www.vogella.com/tutorials/EclipseGradle/article.html",children:"Eclipse / Gradle"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"http://www.vogella.com/tutorials/EclipseMaven/article.html",children:"Eclipse / Maven"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"constructing-the-client",children:"Constructing the client"}),"\n",(0,i.jsxs)(n.p,{children:['As mentioned previously, Discord4J provides higher-level APIs for interacting with Discord. The "entry point" for\r\nany kind of interaction with Discord is the ',(0,i.jsx)(n.code,{children:"DiscordClient"}),". So, the first thing we need to do in our program is\r\nconstruct one. The easiest way to do that is simply using the ",(0,i.jsx)(n.code,{children:"create"})," method."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["More advanced configuration of the client can be done with ",(0,i.jsx)(n.code,{children:"DiscordClientBuilder"}),". The default configuration is fine\r\nfor the purposes of this tutorial."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import discord4j.core.DiscordClient;\r\n\r\npublic class MyBot {\r\n\r\n  public static void main(String[] args) {\r\n    DiscordClient client = DiscordClient.create("TOKEN");\r\n  }\r\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Replace ",(0,i.jsx)(n.code,{children:"TOKEN"}),' with your bot\'s authentication token. This is like a username and password that a normal user\r\nwould use to authenticate with Discord. It can be found in the "Bot" settings page of the developer portal.']}),"\n",(0,i.jsx)(n.h2,{id:"logging-in",children:"Logging In"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.code,{children:"DiscordClient"})," has an important caveat: it presents all of the operations a bot can do ",(0,i.jsx)(n.em,{children:"while not logged in"}),'.\r\nRemember, when a bot is "logged in," it has an active connection to Discord that allows it to receive real-time\r\ninformation. While there are many legitimate use cases for ',(0,i.jsx)(n.em,{children:"just"})," having a non-connected ",(0,i.jsx)(n.code,{children:"DiscordClient"}),", most bots\r\nwill instead require a ",(0,i.jsx)(n.code,{children:"GatewayDiscordClient"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["To obtain a ",(0,i.jsx)(n.code,{children:"GatewayDiscordClient"}),", we will use the ",(0,i.jsx)(n.code,{children:"withGateway"})," method of ",(0,i.jsx)(n.code,{children:"DiscordClient"}),". This method allows us to\r\nsay the bot should do when it logs in. We can use the method like so:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"Mono<Void> login = client.withGateway((GatewayDiscordClient gateway) -> Mono.empty());\r\n\r\nlogin.block();\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We can see that ",(0,i.jsx)(n.code,{children:"withGateway"})," returns a ",(0,i.jsx)(n.code,{children:"Mono<Void>"})," which we have named ",(0,i.jsx)(n.code,{children:"login"}),". Upon subscribing to this Mono,\r\nDiscord4J will establish a connection with Discord and perform the action specified by the argument to ",(0,i.jsx)(n.code,{children:"withGateway"}),"\r\n(i.e., it will invoke the function we passed to ",(0,i.jsx)(n.code,{children:"withGateway"}),"). In this case, we immediately return ",(0,i.jsx)(n.code,{children:"Mono.empty()"}),',\r\nso that action is essentially "do nothing." You can confirm this by running the following updated program and observing\r\nthat the bot comes online in Discord, and the program runs indefinitely.']}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'import discord4j.core.DiscordClient;\r\nimport discord4j.core.GatewayDiscordClient;\r\nimport reactor.core.publisher.Mono;\r\n\r\npublic class MyBot {\r\n\r\n  public static void main(String[] args) {\r\n    DiscordClient client = DiscordClient.create("TOKEN");\r\n\r\n    Mono<Void> login = client.withGateway((GatewayDiscordClient gateway) -> Mono.empty());\r\n\r\n    login.block();\r\n  }\r\n}\r\n\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["Because most bots require a ",(0,i.jsx)(n.code,{children:"GatewayDiscordClient"})," over a ",(0,i.jsx)(n.code,{children:"DiscordClient"}),', you will often see the former referred to as\r\njust "client."']})}),"\n",(0,i.jsx)(n.h2,{id:"responding-to-events",children:"Responding to events"}),"\n",(0,i.jsxs)(n.p,{children:["A bot doing nothing but being online is pretty boring, so let's change that. Recall that Discord sends real-time\r\ninformation to connected clients via events. To listen to these events, we can use the ",(0,i.jsx)(n.code,{children:"on"})," method of\r\n",(0,i.jsx)(n.code,{children:"GatewayDiscordClient"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["This method has several overloads, but the most useful (and safest, refer to the javadocs for more info) is the one\r\nwhich takes a ",(0,i.jsx)(n.code,{children:"Function<E, Publisher<T>>"})," for the second parameter. That function is invoked every time the specified\r\nevent is received from Discord. The Publisher that it returns determines how the event is handled."]}),"\n",(0,i.jsx)(n.p,{children:"Let's look at some concrete examples."}),"\n",(0,i.jsx)(n.h3,{id:"readyevent",children:"ReadyEvent"}),"\n",(0,i.jsxs)(n.p,{children:["First, let's listen to ",(0,i.jsx)(n.code,{children:"ReadyEvent"}),'. Quoting from the javadoc, this event is "dispatched when an initial connection to\r\nthe Discord gateway has been established." We can rewrite our ',(0,i.jsx)(n.code,{children:"withGateway"})," invocation to instead listen to this event\r\nand print some information from it."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'Mono<Void> login = client.withGateway((GatewayDiscordClient gateway) ->\r\n    gateway.on(ReadyEvent.class, event ->\r\n        Mono.fromRunnable(() -> {\r\n          final User self = event.getSelf();\r\n          System.out.printf("Logged in as %s#%s%n", self.getUsername(), self.getDiscriminator());\r\n        })));\r\n    login.block();\n'})}),"\n",(0,i.jsxs)(n.p,{children:["With this code, every occurrence of ",(0,i.jsx)(n.code,{children:"ReadyEvent"}),' is handled by printing the username and discriminator of the "self\r\nuser" which is the user associated with the bot account.']}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"fromRunnable"})," is used because the handler isn't reactive. As we'll see later, this usually isn't the case."]})}),"\n",(0,i.jsxs)(n.p,{children:["When you run the program now, you should see the printed ",(0,i.jsx)(n.code,{children:'"Logged in as ..."'})," line once the bot logs in.  In English,\r\nthis new code essentially says \"when logged in, listen to the ready event, and when it gets dispatched, print 'logged\r\nin as ....'\""]}),"\n",(0,i.jsx)(n.h3,{id:"messagecreateevent",children:"MessageCreateEvent"}),"\n",(0,i.jsxs)(n.p,{children:["Next we'll see how to create our ",(0,i.jsx)(n.code,{children:"!ping"}),' command. Remember, we want the bot to respond to "!ping" with "pong!".']}),"\n",(0,i.jsxs)(n.p,{children:["The setup for listening to the event is exactly the same as with ",(0,i.jsx)(n.code,{children:"ReadyEvent"}),". The only difference is the event we want\r\nto listen to. In this case that's ",(0,i.jsx)(n.code,{children:"MessageCreateEvent"}),'. Again quoting from the javadoc, this event is "dispatched when a\r\nmessage is sent in a message channel."']}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:"Mono<Void> login = client.withGateway((GatewayDiscordClient gateway) ->\r\n    gateway.on(MessageCreateEvent.class, event -> {\r\n      // ... todo ...\r\n    }));\n"})}),"\n",(0,i.jsx)(n.p,{children:'We need to fill in the "todo" with code that checks if the message we received is "!ping" and then responds with "pong!"\r\nif it is. This is fairly straightforward. The main thing here is just knowing which methods will give you access to the\r\ninformation you want. Like any library, this familiarity comes with experience.'}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["A pretty good strategy for exploring a new library is to just type ",(0,i.jsx)(n.code,{children:"someVariable."})," and seeing what suggestions your IDE\r\nhas. For example, without any prior knowledge, you could find that you can get the received message in the event with\r\n",(0,i.jsx)(n.code,{children:"event.getMessage()"})," and the content of that message with ",(0,i.jsx)(n.code,{children:"event.getMessage().getContent()"}),"."]})}),"\n",(0,i.jsx)(n.p,{children:'The final code with "todo" filled in looks like this.'}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'Mono<Void> login = client.withGateway((GatewayDiscordClient gateway) ->\r\n    gateway.on(MessageCreateEvent.class, event -> {\r\n      Message message = event.getMessage();\r\n      \r\n      if (message.getContent().equalsIgnoreCase("!ping")) {\r\n          return message.getChannel()\r\n              .flatMap(channel -> channel.createMessage("pong!"));\r\n      }\r\n\r\n      return Mono.empty();\r\n    }));\n'})}),"\n",(0,i.jsxs)(n.p,{children:['We check if the message content equals (ignoring case) "!ping", and if it does, we handle the event by creating a\r\nmessage in the same channel with the content "pong!". Otherwise, we handle the event by doing nothing (returning\r\n',(0,i.jsx)(n.code,{children:"Mono.empty()"}),")."]}),"\n",(0,i.jsx)(n.p,{children:"At this point, you can probably see how this could be extended to support many more commands. Try adding another one!"}),"\n",(0,i.jsx)(n.p,{children:'And that\'s it! If you run the program and send "!ping" in a channel the bot can see, it will dutifully respond "pong!".'}),"\n",(0,i.jsx)(n.h3,{id:"multiple-events",children:"Multiple Events"}),"\n",(0,i.jsxs)(n.p,{children:["You might have noticed that the ",(0,i.jsx)(n.code,{children:"MessageCreateEvent"})," example overwrote the ",(0,i.jsx)(n.code,{children:"ReadyEvent"}),' one. But what if we want to do\r\nboth? Our bot should both print "Logged in as..." on start up and respond to "!ping" with "pong!". We can easily do\r\nthis with a couple of small modifications and the ',(0,i.jsx)(n.code,{children:"and"})," method."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'Mono<Void> login = client.withGateway((GatewayDiscordClient gateway) -> {\r\n  // ReadyEvent example\r\n  Mono<Void> printOnLogin = gateway.on(ReadyEvent.class, event ->\r\n      Mono.fromRunnable(() -> {\r\n        final User self = event.getSelf();\r\n        System.out.printf("Logged in as %s#%s%n", self.getUsername(), self.getDiscriminator());\r\n      }))\r\n      .then();\r\n\r\n  // MessageCreateEvent example\r\n  Mono<Void> handlePingCommand = gateway.on(MessageCreateEvent.class, event -> {\r\n    Message message = event.getMessage();\r\n\r\n    if (message.getContent().equalsIgnoreCase("!ping")) {\r\n      return message.getChannel()\r\n          .flatMap(channel -> channel.createMessage("pong!"));\r\n    }\r\n\r\n    return Mono.empty();\r\n  }).then();\r\n\r\n  // combine them!\r\n  return printOnLogin.and(handlePingCommand);\r\n});\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The first change you might notice is the addition of ",(0,i.jsx)(n.code,{children:"then()"})," to both handlers. We didn't discuss is previously, but\r\n",(0,i.jsx)(n.code,{children:"gateway.on()"})," returns a ",(0,i.jsx)(n.code,{children:"Flux<T>"})," where ",(0,i.jsx)(n.code,{children:"T"})," is the return type of the event handler function. This allows you to\r\ncontinue operating on the results of the handler. In this case, we don't need to do that, so we can simply ignore\r\nany results with ",(0,i.jsx)(n.code,{children:"then()"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Now that both of the handlers are ",(0,i.jsx)(n.code,{children:"Mono<Void>"}),", we can simply combine them with ",(0,i.jsx)(n.code,{children:"and"}),'. The code can be fluently read as\r\n"when logged in, print on login ',(0,i.jsx)(n.em,{children:"and"}),' handle the ping command."']})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(6540);const o={},s=i.createContext(o);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);