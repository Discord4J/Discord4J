"use strict";(self.webpackChunkdiscord4j_documentation=self.webpackChunkdiscord4j_documentation||[]).push([[231],{2693:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var r=n(4848),i=n(8453);const s={id:"sharding",title:"Sharding",sidebar_label:"Sharding",slug:"/sharding"},o=void 0,a={id:"How-to Guides/sharding",title:"Sharding",description:"What is sharding",source:"@site/docs/04-How-to Guides/sharding.mdx",sourceDirName:"04-How-to Guides",slug:"/sharding",permalink:"/sharding",draft:!1,unlisted:!1,editUrl:"https://github.com/Discord4J/documentation/edit/master/docs/04-How-to Guides/sharding.mdx",tags:[],version:"current",lastUpdatedAt:1631899753e3,frontMatter:{id:"sharding",title:"Sharding",sidebar_label:"Sharding",slug:"/sharding"},sidebar:"mySidebar",previous:{title:"Logging",permalink:"/logging"},next:{title:"Threading",permalink:"/threading"}},d={},l=[{value:"What is sharding",id:"what-is-sharding",level:2},{value:"Enabling the feature",id:"enabling-the-feature",level:2},{value:"Supported architectures",id:"supported-architectures",level:2},{value:"Local configurations",id:"local-configurations",level:3},{value:"Monolith with in-memory entity store",id:"monolith-with-in-memory-entity-store",level:4},{value:"Monolith with custom entity store",id:"monolith-with-custom-entity-store",level:4},{value:"Multiple shard groups under the same JVM",id:"multiple-shard-groups-under-the-same-jvm",level:4},{value:"Distributed configurations",id:"distributed-configurations",level:3},{value:"Introducing Discord4J Connect",id:"introducing-discord4j-connect",level:4},{value:"Writing leaders, reading stateless workers",id:"writing-leaders-reading-stateless-workers",level:4},{value:"Thin leaders, stateless workers",id:"thin-leaders-stateless-workers",level:4},{value:"Dedicated voice workers",id:"dedicated-voice-workers",level:4}];function c(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"what-is-sharding",children:"What is sharding"}),"\n",(0,r.jsx)(t.p,{children:"Sharding is the process a bot guilds are split into multiple connections to the Discord Gateway. Discord requires you to have a max of 2,500 guilds per shard, but the recommended is 1 shard per thousand guilds, so as your bot scales you'll eventually need to switch to a sharding scheme."}),"\n",(0,r.jsxs)(t.p,{children:["Since v3.1, Discord4J takes a different approach to Sharding: a single ",(0,r.jsx)(t.code,{children:"GatewayDiscordClient"}),", created from a ",(0,r.jsx)(t.code,{children:"DiscordClient"}),", represents a ",(0,r.jsx)(t.strong,{children:"shard group"})," where 1 to N Gateway connections are established, each connection represents a shard and will receive updates from a subset of the bot guilds, however, they will be published to a single ",(0,r.jsx)(t.code,{children:"EventDispatcher"})," and ",(0,r.jsx)(t.code,{children:"StoreService"}),". This capability, combined with the modular nature of all Gateway-related components, allows for multiple bot architecture configurations."]}),"\n",(0,r.jsx)(t.h2,{id:"enabling-the-feature",children:"Enabling the feature"}),"\n",(0,r.jsxs)(t.p,{children:["By default, a ",(0,r.jsx)(t.code,{children:"GatewayDiscordClient"})," is configured for automatic sharding capabilities, meaning it will attempt to start the amount of shards Discord recommends given your bot size. When bootstrapping a connection to the Gateway, you can configure this using ",(0,r.jsx)(t.code,{children:".setSharding(ShardingStrategy)"}),"."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'DiscordClient.create(System.getenv("token"))\r\n        .gateway()\r\n        .setSharding(ShardingStrategy.fixed(2))\r\n        .withGateway(client -> client.on(ReadyEvent.class)\r\n                .doOnNext(ready ->\r\n                        log.info("Logged in as {}", ready.getSelf().getUsername()))\r\n                .then())\r\n        .block();\n'})}),"\n",(0,r.jsxs)(t.p,{children:["This example will create a group splitting your bot into 2 shards and connecting to both. ",(0,r.jsx)(t.code,{children:"ShardingStrategy"})," provides some static factories to quickly get started:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"ShardingStrategy.recommended()"})," will provide the recommended amount of shards and include all of them in the group"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"ShardingStrategy.fixed(shardCount)"})," will use the given ",(0,r.jsx)(t.code,{children:"shardCount"})," and include all shards ",(0,r.jsx)(t.code,{children:"0..shardCount-1"})," in the group"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"ShardingStrategy.single()"})," will use a simple [0,1] configuration"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["You can also customize it entirely using ",(0,r.jsx)(t.code,{children:"ShardingStrategy.builder()"})," for features such as:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Set the total number of shards: ",(0,r.jsx)(t.code,{children:"count(int)"})]}),"\n",(0,r.jsxs)(t.li,{children:["Define the shard ID source (defaults from ID 0 to ",(0,r.jsx)(t.code,{children:"shardCount - 1"}),"): statically by ",(0,r.jsx)(t.code,{children:"indices(int...)"})," or based on a ",(0,r.jsx)(t.code,{children:"Publisher"})," using ",(0,r.jsx)(t.code,{children:"indices(Function<Integer, Publisher<Integer>>)"})]}),"\n",(0,r.jsxs)(t.li,{children:["Include only a subset of shard IDs using ",(0,r.jsx)(t.code,{children:"filter(Predicate<ShardInfo>)"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"https://discord.com/developers/docs/topics/gateway#sharding-for-very-large-bots",children:"If your bot supports it"})," allow concurrent Gateway handshakes using ",(0,r.jsx)(t.code,{children:"maxConcurrency(int)"})]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"supported-architectures",children:"Supported architectures"}),"\n",(0,r.jsx)(t.h3,{id:"local-configurations",children:"Local configurations"}),"\n",(0,r.jsxs)(t.p,{children:["If your bot infrastructure is running under the same JVM, your bot runs in a local configuration. This means you can simply use our ",(0,r.jsx)(t.code,{children:"GatewayDiscordClient"}),", appropriately configure ",(0,r.jsx)(t.code,{children:"ShardingStrategy"})," and have a functional sharded bot."]}),"\n",(0,r.jsx)(t.h4,{id:"monolith-with-in-memory-entity-store",children:"Monolith with in-memory entity store"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Defaults to an in-memory (JDK) entity ",(0,r.jsx)(t.code,{children:"Store"})," or can be customized through ",(0,r.jsx)(t.code,{children:"MappingStoreService"})," and libraries like ",(0,r.jsx)(t.a,{href:"https://github.com/Discord4J/Stores/tree/master/caffeine",children:"stores-caffeine"}),"."]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'DiscordClient.create(System.getenv("token"))\r\n        .gateway()\r\n        .setSharding(shardingStrategy)\r\n        .withGateway(client -> { ... })\r\n        .block();\n'})}),"\n",(0,r.jsx)(t.h4,{id:"monolith-with-custom-entity-store",children:"Monolith with custom entity store"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Switch to an external ",(0,r.jsx)(t.code,{children:"StoreService"})," like ",(0,r.jsx)(t.a,{href:"https://github.com/Discord4J/Stores/tree/master/redis",children:"stores-redis"})]}),"\n",(0,r.jsxs)(t.li,{children:["Can be combined with previously mentioned ",(0,r.jsx)(t.code,{children:"MappingStoreService"})," for a customized layout seeking performance and efficiency."]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'DiscordClient.create(System.getenv("token"))\r\n        .gateway()\r\n        .setStoreService(...)\r\n        .setSharding(shardingStrategy)\r\n        .withGateway(client -> { ... })\r\n        .block();\n'})}),"\n",(0,r.jsx)(t.h4,{id:"multiple-shard-groups-under-the-same-jvm",children:"Multiple shard groups under the same JVM"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["If you want to logically split shard groups, you can spawn multiple ",(0,r.jsx)(t.code,{children:"GatewayDiscordClient"})," instances"]}),"\n",(0,r.jsxs)(t.li,{children:["To make use of this pattern, you need to share the same parent ",(0,r.jsx)(t.code,{children:"DiscordClient"})," to get automatically rate limit handling"]}),"\n",(0,r.jsxs)(t.li,{children:["You need to share the ",(0,r.jsx)(t.code,{children:"ShardCoordinator"})," across groups to get Gateway authentication rate limits automatically handled"]}),"\n",(0,r.jsxs)(t.li,{children:["You can ",(0,r.jsx)(t.strong,{children:"optionally"})," share the ",(0,r.jsx)(t.code,{children:"StoreService"}),", just supply the same instance to both Gateway bootstrap calls"]}),"\n",(0,r.jsxs)(t.li,{children:["Can also apply this pattern for the ",(0,r.jsx)(t.em,{children:"same"})," shards to acquire two independent groups for testing, redundancy/failover, etc"]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'// the first group will get even shard IDs\r\nShardingStrategy first = ShardingStrategy.builder()\r\n        .count(10)\r\n        .filter(s -> s.getIndex() % 2 == 0)\r\n        .build();\r\n// the second group will get odd shard IDs\r\nShardingStrategy second = ShardingStrategy.builder()\r\n        .count(10)\r\n        .filter(s -> s.getIndex() % 2 != 0)\r\n        .build();\r\n\r\nDiscordClient sharedClient = DiscordClient.create(System.getenv("token"));\r\n\r\nShardCoordinator coordinator = LocalShardCoordinator.create();\r\n\r\nGatewayDiscordClient firstGroup = sharedClient.gateway()\r\n        .setSharding(first)\r\n        .setEnabledIntents(...)\r\n        .setShardCoordinator(coordinator)\r\n        .login()\r\n        .block();\r\n\r\nGatewayDiscordClient secondGroup = sharedClient.gateway()\r\n        .setSharding(second)\r\n        .setEnabledIntents(...)\r\n        .setShardCoordinator(coordinator)\r\n        .login()\r\n        .block();\n'})}),"\n",(0,r.jsx)(t.h3,{id:"distributed-configurations",children:"Distributed configurations"}),"\n",(0,r.jsx)(t.p,{children:"If you plan to run your bot infrastructure across multiple machines, your bot runs in a distributed configuration. This poses some additional challenges as communication must travel across JVM boundaries. Fortunately there is an ongoing effort from Discord4J collaborators and contributors to support many distributed architectures."}),"\n",(0,r.jsxs)(t.h4,{id:"introducing-discord4j-connect",children:["Introducing ",(0,r.jsx)(t.a,{href:"https://github.com/Discord4J/connect",children:"Discord4J Connect"})]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Connect"})," is a project within the Discord4J organization attempting to provide distributed bot architectures over Discord4J. It goes beyond the JVM and ",(0,r.jsx)(t.em,{children:"connects"})," your bot event flow across multiple middlewares to unlock your bot scaling potential."]}),"\n",(0,r.jsxs)(t.p,{children:["Connect uses the concept of ",(0,r.jsx)(t.strong,{children:"Leader"})," and ",(0,r.jsx)(t.strong,{children:"Worker"})," to express a Discord4J bot topology:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Leaders will establish a websocket connection to Discord Gateway, so they are in charge of handling its lifecycle and delivering payloads to a middleware"}),"\n",(0,r.jsx)(t.li,{children:"Workers are not connecting to Discord Gateway directly and instead receive payloads from the middleware, connecting to it on startup"}),"\n",(0,r.jsx)(t.li,{children:"Middleware is the set of components that need to work in a distributed fashion to communicate to an arbitrary number of Leaders and Workers"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"A typical Middleware is required to provide the following distributed functionality:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"ShardCoordinator"})," to properly throttle and schedule Gateway authentication attempts (IDENTIFY)"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"GlobalRateLimiter"})," to handle global throttling of requests correctly, even across boundaries"]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"Router"})," to coordinate REST API requests, taking rate limit buckets into account, even across boundaries"]}),"\n",(0,r.jsx)(t.li,{children:"A broker or equivalent middleware to route Gateway payloads between Leaders and Workers"}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"StoreService"})," that can offer an entity cache to the whole topology"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Connect project is attempting to provide implementations for each of the previous elements. Technologies such as RSocket, RabbitMQ and redis are used, and more are planned to offer a multitude of options to choose from."}),"\n",(0,r.jsxs)(t.p,{children:["Please check the ",(0,r.jsx)(t.a,{href:"https://github.com/Discord4J/connect/tree/master/examples",children:"examples folder"})," for information about how to set up a distributed bot using connect."]}),"\n",(0,r.jsx)(t.h4,{id:"writing-leaders-reading-stateless-workers",children:"Writing leaders, reading stateless workers"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Leader is in charge of writing to the entity cache and routing Gateway payloads"}),"\n",(0,r.jsx)(t.li,{children:"Workers read from the distributed entity cache and process commands"}),"\n",(0,r.jsx)(t.li,{children:"Workers are not tied to any particular shard, but the payload broker/middleware can route"}),"\n"]}),"\n",(0,r.jsx)("img",{src:"/img/distributed-discord4j-bot-writer-leaders.svg"}),"\n",(0,r.jsx)(t.h4,{id:"thin-leaders-stateless-workers",children:"Thin leaders, stateless workers"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Transfer the Gateway payload processing load to the workers and free resources on the leader side"}),"\n",(0,r.jsx)(t.li,{children:"Workers read Gateway payloads, write to the entity cache and process commands"}),"\n",(0,r.jsx)(t.li,{children:"Workers are not tied to any particular shard, but the payload broker/middleware can route"}),"\n"]}),"\n",(0,r.jsx)("img",{src:"/img/distributed-discord4j-bot-thin-leaders.svg"}),"\n",(0,r.jsx)(t.h4,{id:"dedicated-voice-workers",children:"Dedicated voice workers"}),"\n",(0,r.jsx)(t.p,{children:"It is planned that Discord4J Connect supports distributed audio processing. The interfaces in the voice module exist, but they lack a distributed-capable implementation."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var r=n(6540);const i={},s=r.createContext(i);function o(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);