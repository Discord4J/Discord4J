"use strict";(self.webpackChunkdiscord4j_documentation=self.webpackChunkdiscord4j_documentation||[]).push([[350],{8545:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var o=n(4848),t=n(8453);const s={id:"error-handling",title:"Error Handling",sidebar_label:"Error Handling",slug:"/error-handling"},a=void 0,i={id:"How-to Guides/error-handling",title:"Error Handling",description:"For a more detailed source of information, please refer to this section of the Reactor reference guide.",source:"@site/docs/04-How-to Guides/error-handling.mdx",sourceDirName:"04-How-to Guides",slug:"/error-handling",permalink:"/error-handling",draft:!1,unlisted:!1,editUrl:"https://github.com/Discord4J/documentation/edit/master/docs/04-How-to Guides/error-handling.mdx",tags:[],version:"current",lastUpdatedAt:1631918071e3,frontMatter:{id:"error-handling",title:"Error Handling",sidebar_label:"Error Handling",slug:"/error-handling"},sidebar:"mySidebar",previous:{title:"Embeds",permalink:"/embeds"},next:{title:"Logging",permalink:"/logging"}},c={},l=[{value:"Handling Errors",id:"handling-errors",level:2},{value:"Accept the error",id:"accept-the-error",level:3},{value:"Catch and return a static default value: <code>onErrorReturn</code>",id:"catch-and-return-a-static-default-value-onerrorreturn",level:3},{value:"Catch and execute an alternative path with a fallback method: <code>onErrorResume</code>",id:"catch-and-execute-an-alternative-path-with-a-fallback-method-onerrorresume",level:3},{value:"Catch and Rethrow: <code>onErrorMap</code>",id:"catch-and-rethrow-onerrormap",level:3},{value:"Retrying: <code>retry</code>, <code>retryWhen</code>",id:"retrying-retry-retrywhen",level:3},{value:"Catch and continue mode",id:"catch-and-continue-mode",level:3},{value:"<code>onErrorContinue</code>",id:"onerrorcontinue",level:4},{value:"<code>onErrorStop</code>",id:"onerrorstop",level:4},{value:"Error Sources",id:"error-sources",level:2},{value:"Handling errors across multiple requests using Discord4J",id:"handling-errors-across-multiple-requests-using-discord4j",level:2}];function d(e){const r={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.admonition,{type:"note",children:(0,o.jsxs)(r.p,{children:["For a more detailed source of information, please refer to ",(0,o.jsx)(r.a,{href:"https://projectreactor.io/docs/core/release/reference/#error.handling",children:"this section"})," of the Reactor reference guide."]})}),"\n",(0,o.jsxs)(r.p,{children:["According to reactive streams specification, errors are terminal signals. This typically means any running sequence will be ",(0,o.jsx)(r.strong,{children:"terminated"})," and the error propagated to all operators down the chain."]}),"\n",(0,o.jsx)(r.h2,{id:"handling-errors",children:"Handling Errors"}),"\n",(0,o.jsx)(r.p,{children:"The following are some valid strategies for dealing with errors:"}),"\n",(0,o.jsx)(r.h3,{id:"accept-the-error",children:"Accept the error"}),"\n",(0,o.jsxs)(r.p,{children:["Error will propagate downstream until the end of the chain and then run the ",(0,o.jsx)(r.code,{children:"onError"})," callback in your subscriber."]}),"\n",(0,o.jsxs)(r.p,{children:["You can optionally log and react on the side using ",(0,o.jsx)(r.code,{children:"doOnError"})," operator."]}),"\n",(0,o.jsxs)(r.p,{children:["As good practice, we encourage you to ",(0,o.jsxs)(r.strong,{children:["implement the ",(0,o.jsx)(r.code,{children:"onError"})," callback"]})," when subscribing to be properly notified. If you don't override the ",(0,o.jsx)(r.code,{children:"onError"})," callback, you will receive a Reactor ",(0,o.jsx)(r.code,{children:"ErrorCallbackNotImplemented"})," exception wrapping your original exception."]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-java",children:'client.getEventDispatcher().on(MessageCreateEvent.class)\r\n    .map(MessageCreateEvent::getMessage)\r\n    .filter(message -> message.getAuthor().map(user -> !user.isBot()).orElse(false))\r\n    .filter(message -> message.getContent().equalsIgnoreCase("!ping"))\r\n    .flatMap(Message::getChannel)\r\n    .flatMap(channel -> channel.createMessage("Pong!"))\r\n    .doOnError(error -> { /* You can be notified here as well! */ })\r\n    .subscribe(null, error -> {\r\n        // the error signal will stop here and terminate the sequence\r\n        System.out.println(e);\r\n    });\n'})}),"\n",(0,o.jsxs)(r.p,{children:["\u26a0\ufe0f Taking this approach under ",(0,o.jsx)(r.code,{children:"EventDispatcher"})," sequences will terminate your subscription, missing all further events for that subscriber. In general, this is a poor solution if you wish to perform extra behavior like starting another chain."]}),"\n",(0,o.jsxs)(r.h3,{id:"catch-and-return-a-static-default-value-onerrorreturn",children:[(0,o.jsx)(r.a,{href:"https://projectreactor.io/docs/core/release/reference/#_static_fallback_value",children:"Catch and return a static default value"}),": ",(0,o.jsx)(r.code,{children:"onErrorReturn"})]}),"\n",(0,o.jsx)(r.p,{children:"\u2714\ufe0f This approach is good for individual API requests when you want to return a value in case of an error."}),"\n",(0,o.jsxs)(r.p,{children:["\u26a0\ufe0f Taking this approach with ",(0,o.jsx)(r.code,{children:"EventDispatcher"})," will terminate the sequence, and no further events will be received by that subscriber, unless you apply this operator to an inner sequence, without affecting the outer one containing all events, like this example:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-java",children:'client.getEventDispatcher().on(MessageCreateEvent.class)\r\n    .map(MessageCreateEvent::getMessage)\r\n    .filter(message -> message.getAuthor().map(user -> !user.isBot()).orElse(false))\r\n    .filter(message -> message.getContent().startsWith("!user "))\r\n    .flatMap(message -> Mono.just(message.getContent())\r\n        .map(content -> content.split(" ", 2))\r\n        .flatMap(tokens -> message.getClient().getUserById(Snowflake.of(tokens[1])))\r\n        .map(user -> user.getUsername() + "#" + user.getDiscriminator())\r\n            .onErrorReturn("Could not find that user") // Replaces errors with this msg\r\n        .flatMap(name -> message.getChannel()\r\n            .flatMap(channel -> channel.createMessage(name))))\r\n    .subscribe(null, System.out::println);\n'})}),"\n",(0,o.jsxs)(r.p,{children:["onErrorReturn has overloads to include a condition so you could for example use the following to only recover from ",(0,o.jsx)(r.code,{children:"404"})," status errors (Not found):"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-java",children:'.onErrorReturn(ClientException.isStatusCode(404), "Could not find that user")\n'})}),"\n",(0,o.jsxs)(r.h3,{id:"catch-and-execute-an-alternative-path-with-a-fallback-method-onerrorresume",children:[(0,o.jsx)(r.a,{href:"https://projectreactor.io/docs/core/release/reference/#_fallback_method",children:"Catch and execute an alternative path with a fallback method"}),": ",(0,o.jsx)(r.code,{children:"onErrorResume"})]}),"\n",(0,o.jsx)(r.p,{children:"\u2714\ufe0f This approach is good for individual API requests when you want to provide alternative behavior."}),"\n",(0,o.jsxs)(r.p,{children:["\u2714\ufe0f This approach is great when working inside a ",(0,o.jsx)(r.code,{children:"flatMap"})," with ",(0,o.jsx)(r.code,{children:"EventDispatcher"}),", as you will replace the sequence with, for example, ",(0,o.jsx)(r.code,{children:"Mono.empty()"})," effectively suppresing the error while maintaining the original sequence."]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-java",children:'Flux.just("\ud83d\ude00", "\ud83d\ude2c", "\ud83d\ude02", "\ud83d\ude04")\r\n    .flatMap(emoji -> message.addReaction(ReactionEmoji.unicode(emoji))\r\n        .onErrorResume(e -> Mono.empty()) // error is discarded\r\n    )\r\n    .subscribe(); // so it won\'t get here\n'})}),"\n",(0,o.jsxs)(r.p,{children:["If you were to place ",(0,o.jsx)(r.code,{children:"onErrorResume"})," outside a ",(0,o.jsx)(r.code,{children:"flatMap"}),", you'll replace the sequence, potentially missing some elements being processed:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-java",children:'Flux.just("\ud83d\ude00", "\ud83d\ude2c", "\ud83d\ude02", "\ud83d\ude04")\r\n\r\n    // if this fails on the 3rd emoji\r\n    .flatMap(emoji -> message.addReaction(ReactionEmoji.unicode(emoji)))\r\n\r\n    // you\'ll replace the sequence with an empty one, and miss the last one\r\n    .onErrorResume(e -> Mono.empty())\r\n\r\n    // but the error still won\'t reach here!\r\n    .subscribe();\n'})}),"\n",(0,o.jsxs)(r.h3,{id:"catch-and-rethrow-onerrormap",children:[(0,o.jsx)(r.a,{href:"https://projectreactor.io/docs/core/release/reference/#_catch_and_rethrow",children:"Catch and Rethrow"}),": ",(0,o.jsx)(r.code,{children:"onErrorMap"})]}),"\n",(0,o.jsxs)(r.p,{children:["\u2714\ufe0f This approach is good for individual API requests when you want to translate the error, typically ",(0,o.jsx)(r.code,{children:"ClientException"}),", to a type you control for additional behavior downstream."]}),"\n",(0,o.jsxs)(r.p,{children:["\u2714\ufe0f This approach is good when working with ",(0,o.jsx)(r.code,{children:"EventDispatcher"})," for the same reason as above. Be aware that the sequence is still on error and can be handled by a different strategy on following operators."]}),"\n",(0,o.jsxs)(r.h3,{id:"retrying-retry-retrywhen",children:[(0,o.jsx)(r.a,{href:"https://projectreactor.io/docs/core/release/reference/#_retrying",children:"Retrying"}),": ",(0,o.jsx)(r.code,{children:"retry"}),", ",(0,o.jsx)(r.code,{children:"retryWhen"})]}),"\n",(0,o.jsxs)(r.p,{children:["Error will terminate the original sequence, but ",(0,o.jsx)(r.code,{children:"retry()"})," (and ",(0,o.jsx)(r.a,{href:"https://projectreactor.io/docs/core/release/reference/#_retrying",children:"variants"}),") will ",(0,o.jsx)(r.strong,{children:"re-subscribe"})," to the upstream Flux. Be aware that this ultimately means that a new sequence is created."]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-java",children:'client.getEventDispatcher().on(MessageCreateEvent.class)\r\n    .map(MessageCreateEvent::getMessage)\r\n    .filter(message -> message.getAuthor().map(user -> !user.isBot()).orElse(false))\r\n    .filter(message -> message.getContent().equalsIgnoreCase("!ping"))\r\n    .flatMap(Message::getChannel)\r\n    .flatMap(channel -> channel.createMessage("Pong!"))\r\n    .retry()\r\n    .subscribe();\n'})}),"\n",(0,o.jsx)(r.p,{children:"\u26a0\ufe0f This approach is generally appropriate for API requests, but there are certain errors you should not retry. By default, Discord4J retries some errors for you, using an exponential backoff with jitter strategy."}),"\n",(0,o.jsxs)(r.p,{children:["\u2714\ufe0f This approach is compatible with ",(0,o.jsx)(r.code,{children:"EventDispatcher"})," sources when using the ",(0,o.jsx)(r.a,{href:"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/EmitterProcessor.html",children:"default event processor"}),", due to it only relaying events since the time of subscription. As retrying creates a new subscription, the erroring event will be discarded and the sequence will continue from the next event."]}),"\n",(0,o.jsx)(r.h3,{id:"catch-and-continue-mode",children:"Catch and continue mode"}),"\n",(0,o.jsx)(r.h4,{id:"onerrorcontinue",children:(0,o.jsx)(r.code,{children:"onErrorContinue"})}),"\n",(0,o.jsxs)(r.p,{children:["\u26a0\ufe0f This only works ",(0,o.jsx)(r.strong,{children:"on supporting operators"}),": ",(0,o.jsx)(r.code,{children:"flatMap"}),", ",(0,o.jsx)(r.code,{children:"map"})," and ",(0,o.jsx)(r.code,{children:"filter"}),", among others according to their javadocs. This operator goes beyond the Reactive Streams spec and uses the Reactor Context to work, therefore it is prone to issues when combining it with unsupported operators. Only use this operator if you understand the consequences, or you're familiar with how Reactor Context works."]}),"\n",(0,o.jsxs)(r.p,{children:["Applying ",(0,o.jsx)(r.code,{children:"onErrorContinue"})," on a ",(0,o.jsx)(r.code,{children:"Flux"})," will change the default behavior of treating errors as terminal events to discarding erroneous elements and keeping the same sequence active."]}),"\n",(0,o.jsx)(r.p,{children:'We do not recommend the usage of this operator for error handling purposes. Instead, try this "resuming to empty" pattern, preventing the error from continuing downstream:'}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-java",children:'...flatMap(source -> reactiveOperationThatMightError()\r\n        .doOnError(error -> log.info("Error encountered while processing {}", source, error))\r\n        .onErrorResume(error -> Mono.empty()))\n'})}),"\n",(0,o.jsx)(r.h4,{id:"onerrorstop",children:(0,o.jsx)(r.code,{children:"onErrorStop"})}),"\n",(0,o.jsxs)(r.p,{children:["Using ",(0,o.jsx)(r.code,{children:"onErrorStop"})," will revert the behavior to treating errors as terminal events. This can be used to accurately scope continue strategy and avoid surprises, specially when combining it with ",(0,o.jsx)(r.code,{children:"onErrorResume"}),"."]}),"\n",(0,o.jsx)(r.h2,{id:"error-sources",children:"Error Sources"}),"\n",(0,o.jsx)(r.p,{children:"Typical Reactor operators will throw errors if you:"}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:["Throw any ",(0,o.jsx)(r.code,{children:"RuntimeException"})," inside a lambda within an operator (see ",(0,o.jsx)(r.a,{href:"https://projectreactor.io/docs/core/release/reference/#_handling_exceptions_in_operators_or_functions",children:"4.6.2"})," for an in-depth explanation)"]}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-java",children:'Flux.just(1, 2, 0)\r\n    .map(i -> "100 / " + i + " = " + (100 / i)) // this triggers an error with 0\r\n    .subscribe();\n'})}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:"Transform a signal into an error one"}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-java",children:'Flux.just("Mega", "Micro", "Nano")\r\n    .flatMap(s -> {\r\n        if (s.startsWith("M")) {\r\n            return Mono.just(s);\r\n        } else {\r\n            return Mono.error(new RuntimeException());\r\n        }\r\n    })\r\n    .subscribe();\n'})}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:"Receive an HTTP error code (400s or 500s)"}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-java",children:'client.getEventDispatcher().on(MessageCreateEvent.class)\r\n    .map(MessageCreateEvent::getMessage)\r\n    .filter(message -> message.getAuthor().map(user -> !user.isBot()).orElse(false))\r\n    .filter(message -> message.getContent().equalsIgnoreCase("!ping"))\r\n    .flatMap(Message::getChannel)\r\n    .flatMap(channel -> channel.createMessage("Pong!")) // can fail with 403, 500, ...\r\n    .subscribe();\n'})}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:["Return ",(0,o.jsx)(r.code,{children:"null"})," (except some documented cases)"]}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-java",children:"Flux.just(1, 2, 3)\r\n    .map(n -> null) // illegal operation\r\n    .subscribe();\n"})}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsx)(r.li,{children:"Overflow due to not generating enough demand"}),"\n"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-java",children:'// Generate a tick every 10 ms\r\nFlux.interval(Duration.ofMillis(10))\r\n    //.onBackpressureDrop() // uncommenting this avoids the error: drop tick if consumer is choked\r\n    .flatMap(tick -> Mono.never()) // would "never" consume the upstream ticks, overflows\r\n    .subscribe();\n'})}),"\n",(0,o.jsx)(r.h2,{id:"handling-errors-across-multiple-requests-using-discord4j",children:"Handling errors across multiple requests using Discord4J"}),"\n",(0,o.jsxs)(r.p,{children:["Until now, we have seen examples that deal with error handling on particular sequences, and while you should continue to use these patterns for most use cases, you might find yourself applying the same operator to a lot of requests. For those cases, Discord4J provides a way to install an error handler across many or all requests made by a ",(0,o.jsx)(r.code,{children:"DiscordClient"}),"."]}),"\n",(0,o.jsxs)(r.p,{children:["When you build a Discord4J client through ",(0,o.jsx)(r.code,{children:"DiscordClientBuilder"})," you'll notice that there are many setters for a variety of customization. You can handle errors in multiple requests by providing a custom ",(0,o.jsx)(r.code,{children:"ResponseFunction"})," through ",(0,o.jsx)(r.code,{children:"onClientResponse"})," method."]}),"\n",(0,o.jsx)(r.p,{children:"You could, for example, build your clients this way:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-java",children:"import discord4j.rest.http.client.ClientException;\r\nimport discord4j.rest.request.RouteMatcher;\r\nimport discord4j.rest.response.ResponseFunction;\r\nimport discord4j.rest.route.Routes;\r\nimport reactor.retry.Retry;\r\n\r\nimport java.time.Duration;\r\n\r\npublic class ExampleClientResponse {\r\n\r\n    public static void main(String[] args) {\r\n        DiscordClient client = DiscordClientBuilder.create(token)\r\n            // globally suppress any not found (404) error\r\n            .onClientResponse(ResponseFunction.emptyIfNotFound())\r\n            // bad requests (400) while adding reactions will be suppressed\r\n            .onClientResponse(ResponseFunction.emptyOnErrorStatus(\r\n                    RouteMatcher.route(Routes.REACTION_CREATE), 400)\r\n            )\r\n            // server error (500) while creating a message will be retried with backoff\r\n            // until it succeeds\r\n            .onClientResponse(\r\n                ResponseFunction.retryWhen(\r\n                        RouteMatcher.route(Routes.MESSAGE_CREATE),\r\n                        Retry.onlyIf(ClientException.isRetryContextStatusCode(500))\r\n                            .exponentialBackoffWithJitter(\r\n                                Duration.ofSeconds(2), Duration.ofSeconds(10)\r\n                            )\r\n                )\r\n            )\r\n            // wait 1 second and retry any server error (500)\r\n            .onClientResponse(ResponseFunction.retryOnceOnErrorStatus(500))\r\n            .build();\r\n    }\r\n}\n"})}),"\n",(0,o.jsxs)(r.p,{children:["Each time ",(0,o.jsx)(r.code,{children:"onClientResponse"})," is called, you're adding a strategy to transform each response made by the ",(0,o.jsx)(r.code,{children:"DiscordClient"}),". If an error occurs, Discord4J processes the error through the following handlers:"]}),"\n",(0,o.jsxs)(r.ol,{children:["\n",(0,o.jsx)(r.li,{children:"Handle rate limiting errors (429), these cannot be modified."}),"\n",(0,o.jsxs)(r.li,{children:["Handle the errors using the ones installed by ",(0,o.jsx)(r.code,{children:"onClientResponse"}),"."]}),"\n",(0,o.jsx)(r.li,{children:"Handle server errors (500s) and retry them using exponential backoff."}),"\n"]}),"\n",(0,o.jsx)(r.p,{children:"The first handler that matches will consume the error and apply its strategy, meaning that the order of declaration is important."}),"\n",(0,o.jsxs)(r.p,{children:["You can look at the ",(0,o.jsx)(r.a,{href:"https://www.javadoc.io/doc/com.discord4j/discord4j-rest/latest/discord4j/rest/response/ResponseFunction.html",children:(0,o.jsx)(r.code,{children:"ResponseFunction"})})," class for commonly used error handlers. A version covering all requests is available, but also a version allowing you to apply the handler to only some API Routes, with the support of ",(0,o.jsx)(r.a,{href:"https://www.javadoc.io/doc/com.discord4j/discord4j-rest/latest/discord4j/rest/request/RouteMatcher.html",children:(0,o.jsx)(r.code,{children:"RouteMatcher"})}),". Explore the ",(0,o.jsx)(r.a,{href:"https://www.javadoc.io/doc/com.discord4j/discord4j-rest/latest/index.html",children:"Javadocs"})," for the rest module to understand more."]})]})}function h(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>i});var o=n(6540);const t={},s=o.createContext(t);function a(e){const r=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),o.createElement(s.Provider,{value:r},e.children)}}}]);