"use strict";(self.webpackChunkdiscord4j_documentation=self.webpackChunkdiscord4j_documentation||[]).push([[851],{5644:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var t=s(4848),i=s(8453);const r={id:"specs",title:"Specs",sidebar_label:"Specs",slug:"/specs"},a=void 0,c={id:"Reference/specs",title:"Specs",description:"Introduction",source:"@site/docs/05-Reference/specs.mdx",sourceDirName:"05-Reference",slug:"/specs",permalink:"/specs",draft:!1,unlisted:!1,editUrl:"https://github.com/Discord4J/documentation/edit/master/docs/05-Reference/specs.mdx",tags:[],version:"current",lastUpdatedAt:1631899753e3,frontMatter:{id:"specs",title:"Specs",sidebar_label:"Specs",slug:"/specs"},sidebar:"mySidebar",previous:{title:"Interactions",permalink:"/interactions"},next:{title:"Versions",permalink:"/versions"}},o={},l=[{value:"Introduction",id:"introduction",level:2},{value:"New immutable Specs (v3.2)",id:"new-immutable-specs-v32",level:2},{value:"Fluent Mono request",id:"fluent-mono-request",level:3},{value:"Spec with copy methods",id:"spec-with-copy-methods",level:3},{value:"Builder pattern",id:"builder-pattern",level:3},{value:"Consumer-based Specs",id:"consumer-based-specs",level:2},{value:"Example",id:"example",level:3},{value:"Templates",id:"templates",level:3}];function d(e){const n={admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)(n.p,{children:["Specs, short for Specification(s), are the way Discord4J encapsulates API request parameter building from our core module. They can handle requests that contain multiple ",(0,t.jsx)(n.em,{children:"optional"})," properties."]}),"\n",(0,t.jsx)(n.p,{children:"There are multiple ways of interacting with them and building them, starting from v3.2."}),"\n",(0,t.jsx)(n.h2,{id:"new-immutable-specs-v32",children:"New immutable Specs (v3.2)"}),"\n",(0,t.jsx)(n.h3,{id:"fluent-mono-request",children:"Fluent Mono request"}),"\n",(0,t.jsxs)(n.p,{children:["An API request without parameters is a ",(0,t.jsx)(n.code,{children:"Mono"})," that can be subscribed or composed to perform the request."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'channel.createMessage("Hey")\r\n    .withComponents(ActionRow.of(Button.success("hey", "Click me!")))\r\n    .subscribe();\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Remember that nothing happens until you subscribe! This can be used to your advantage by reusing the ",(0,t.jsx)(n.code,{children:"Mono"})," pipeline you build after each ",(0,t.jsx)(n.code,{children:"withX"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"spec-with-copy-methods",children:"Spec with copy methods"}),"\n",(0,t.jsxs)(n.p,{children:["An immutable ",(0,t.jsx)(n.code,{children:"Spec"})," that can be shared across components and used for templating. Each ",(0,t.jsx)(n.code,{children:"with"})," call copies the previous instance to maintain immutability and ensure thread-safety."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'MessageCreateSpec spec = MessageCreateSpec.create()\r\n    .withContent("Hey")\r\n    .withComponents(ActionRow.of(Button.success("hey", "Click me!")));\r\n\r\nchannel.createMessage(spec).subscribe();\n'})}),"\n",(0,t.jsx)(n.h3,{id:"builder-pattern",children:"Builder pattern"}),"\n",(0,t.jsxs)(n.p,{children:["A more traditional builder pattern approach. Make sure you call ",(0,t.jsx)(n.code,{children:"builder"})," on the right spec for an instance you can configure to your liking."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'MessageCreateSpec spec = MessageCreateSpec.builder()\r\n        .content("Hey")\r\n        .addComponent(ActionRow.of(Button.success("hey", "Click me!")))\r\n        .build();\r\n\r\nchannel.createMessage(spec).subscribe();\n'})}),"\n",(0,t.jsx)(n.h2,{id:"consumer-based-specs",children:"Consumer-based Specs"}),"\n",(0,t.jsx)(n.p,{children:"Prior to Discord4J v3.2 this was the only alternative to building requests, it follows two principles:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["The end-user does ",(0,t.jsx)(n.strong,{children:"not"})," construct the builder."]}),"\n",(0,t.jsxs)(n.li,{children:["The end-user does ",(0,t.jsx)(n.strong,{children:"not"})," construct the finalized object."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These two characteristics provide Discord4J with a flexible approach regarding constructing requests, without breaking the API at a future date."}),"\n",(0,t.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,t.jsxs)(n.p,{children:["All Specs that an end user interacts with will be provided via a ",(0,t.jsx)(n.code,{children:"Consumer"}),". For example, for ",(0,t.jsx)(n.code,{children:"MessageChannel#createMessage"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"messageChannel.createMessage(spec -> /* manipulate the spec */)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["One may note that all ",(0,t.jsx)(n.code,{children:"Spec"})," instances have an ",(0,t.jsx)(n.code,{children:"asRequest"}),' method. This method is an internal behaviorally implementation-specific method and should never be called by the end-user. Once the Spec has been "built", simply leave it alone.']}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'Mono<Message> message = messageChannel.createMessage(messageSpec -> {\r\n    messageSpec.setContent("Content not in an embed!");\r\n    // You can see in this example, even with simple singular property defining specs\r\n    // the syntax is concise\r\n    messageSpec.setEmbed(embedSpec ->\r\n        embedSpec.setDescription("Description is in an embed!")\r\n    );\r\n});\n'})}),"\n",(0,t.jsx)(n.h3,{id:"templates",children:"Templates"}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"For templates, it is more convenient to use the new immutable specs."})}),"\n",(0,t.jsxs)(n.p,{children:["Using ",(0,t.jsx)(n.code,{children:"Consumer#andThen"})," allows this pattern to be implemented:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"Consumer<EmbedCreateSpec> template = spec -> {\r\n    // Edit the spec as you normally would\r\n};\r\n...\r\n// embedSpec can be edited as you normally would, but the edits from template will\r\n// already be applied\r\nMono<Message> message = messageChannel.createMessage(messageSpec ->\r\n    messageSpec.setEmbed(template.andThen(embedSpec -> {}))\r\n);\n"})}),"\n",(0,t.jsxs)(n.p,{children:['This pattern additionally helps protect the end-user from accidentally sharing specs across multiple invocations, as the state is never "reset" and mutating these legacy ',(0,t.jsx)(n.code,{children:"Spec"})," instances is ",(0,t.jsx)(n.strong,{children:"not"})," thread-safe."]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>c});var t=s(6540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);