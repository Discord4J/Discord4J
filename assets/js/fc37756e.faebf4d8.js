"use strict";(self.webpackChunkdiscord4j_documentation=self.webpackChunkdiscord4j_documentation||[]).push([[543],{1279:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var s=i(4848),t=i(8453);const o={id:"migrating-from-v2-x-to-v3-1",title:"Migrating from v2.x to v3.1",sidebar_label:"Migrating from v2.x to v3.1",slug:"/migrating-from-v2-x-to-v3-1"},r=void 0,a={id:"Migration Guides/migrating-from-v2-x-to-v3-1",title:"Migrating from v2.x to v3.1",description:"Introduction",source:"@site/docs/07-Migration Guides/migrating-from-v2-x-to-v3-1.mdx",sourceDirName:"07-Migration Guides",slug:"/migrating-from-v2-x-to-v3-1",permalink:"/migrating-from-v2-x-to-v3-1",draft:!1,unlisted:!1,editUrl:"https://github.com/Discord4J/documentation/edit/master/docs/07-Migration Guides/migrating-from-v2-x-to-v3-1.mdx",tags:[],version:"current",lastUpdatedAt:1632891245e3,frontMatter:{id:"migrating-from-v2-x-to-v3-1",title:"Migrating from v2.x to v3.1",sidebar_label:"Migrating from v2.x to v3.1",slug:"/migrating-from-v2-x-to-v3-1"},sidebar:"mySidebar",previous:{title:"Reactive (Reactor) Tutorial",permalink:"/reactive-reactor-tutorial"},next:{title:"Migrating from v3.0 to v3.1",permalink:"/migrating-from-v3-0-to-v3-1"}},c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Blocking",id:"blocking",level:2},{value:"JDA Developers",id:"jda-developers",level:3},{value:"Javacord Developers",id:"javacord-developers",level:3},{value:"EventDispatcher and IListener",id:"eventdispatcher-and-ilistener",level:2},{value:"ReadyEvent",id:"readyevent",level:2},{value:"FAQ",id:"faq",level:2},{value:"What is wrong with v2?",id:"what-is-wrong-with-v2",level:4},{value:"Where is <code>RequestBuffer</code>/<code>RequestBuilder</code>?",id:"where-is-requestbufferrequestbuilder",level:4},{value:"Where is <code>MessageHistory</code>?",id:"where-is-messagehistory",level:4},{value:"Migration steps",id:"migration-steps",level:2},{value:"Client building",id:"client-building",level:3},{value:"Event dispatching",id:"event-dispatching",level:3},{value:"Event processing",id:"event-processing",level:3},{value:"Working with permissions",id:"working-with-permissions",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"Discord4J v3 is a completely different programming paradigm compared to v2. Rather than it being focused around synchronous, blocking invocations; everything is handled in an asynchronous, reactive context. The API has also been completely refactored, allowing D4J to provide a much cleaner, richer, consistent, and flexible approach to bot development."}),"\n",(0,s.jsx)(n.h2,{id:"blocking",children:"Blocking"}),"\n",(0,s.jsxs)(n.p,{children:["The core of Discord4J's design is centered around ",(0,s.jsx)(n.a,{href:"/reactive-reactor-tutorial",children:"reactive programming"}),", using Reactor as its implementation. This is primarily focused around 2 classes, ",(0,s.jsx)(n.code,{children:"Mono"})," and ",(0,s.jsx)(n.code,{children:"Flux"}),". While ",(0,s.jsx)(n.code,{children:"Mono"})," and ",(0,s.jsx)(n.code,{children:"Flux"})," are designed for asynchronous computations, they do offer synchronous conversions for more traditional imperative programming that will be familiar to v2 developers."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Blocking completely eliminates any and all benefits of reactive programming. We ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.em,{children:"highly"})})," recommend that you learn more about reactive programming and eventually convert your code to be more reactive after the initial migration for better performance and scalability."]})}),"\n",(0,s.jsxs)(n.p,{children:["Any method that returns a ",(0,s.jsx)(n.code,{children:"Mono"})," or ",(0,s.jsx)(n.code,{children:"Flux"}),' must be "subscribed" to in order for an action to be performed. This is vastly different compared to v2, where simply invoking the method ',(0,s.jsx)(n.em,{children:"instantly"})," caused the method to execute. To mimic that behavior, we can simply call ",(0,s.jsx)(n.code,{children:"Mono#block"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'TextChannel channel = (TextChannel) discordClient\r\n    .getChannelById(Snowflake.of(1234567890L))\r\n    .block();\r\nchannel.createMessage("Hello World").block();\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Flux"})," can be converted to a ",(0,s.jsx)(n.code,{children:"Mono"})," using ",(0,s.jsx)(n.code,{children:"Flux#collectList"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"List<Role> roles = guild.getRoles().collectList().block();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"jda-developers",children:"JDA Developers"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Mono"})," is a significantly more powerful version of ",(0,s.jsx)(n.code,{children:"RestAction"}),". It provides both an analog to ",(0,s.jsx)(n.code,{children:"queue"})," and ",(0,s.jsx)(n.code,{children:"complete"})," (",(0,s.jsx)(n.code,{children:"subscribe"})," and ",(0,s.jsx)(n.code,{children:"block"}),") while additionally providing more operations for easier and more generic handling of data and actions both synchronously and asynchronously."]}),"\n",(0,s.jsx)(n.h3,{id:"javacord-developers",children:"Javacord Developers"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Mono"})," is a significantly more powerful version of ",(0,s.jsx)(n.code,{children:"CompletableFuture"}),". It provides a more concise, standard, and easier manipulation of data and actions asynchronously compared to ",(0,s.jsx)(n.code,{children:"CompletableFuture"}),"'s copious amounts of ",(0,s.jsx)(n.code,{children:"apply"})," and ",(0,s.jsx)(n.code,{children:"handle"})," methods and still provides an analog to ",(0,s.jsx)(n.code,{children:"get"})," (or ",(0,s.jsx)(n.code,{children:"await"}),") via ",(0,s.jsx)(n.code,{children:"Mono#block"}),". In fact, a ",(0,s.jsx)(n.code,{children:"Mono"})," can be converted ",(0,s.jsx)(n.a,{href:"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#toFuture--",children:"to"})," and ",(0,s.jsx)(n.a,{href:"https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromFuture-java.util.concurrent.CompletableFuture-",children:"from"})," a ",(0,s.jsx)(n.code,{children:"CompletableFuture"})," natively."]}),"\n",(0,s.jsx)(n.h2,{id:"eventdispatcher-and-ilistener",children:"EventDispatcher and IListener"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"EventDispatcher"})," has been reworked and ",(0,s.jsx)(n.code,{children:"IListener"})," (and consequently ",(0,s.jsx)(n.code,{children:"@EventSubscriber"}),') has been completely removed in v3. To "listen" for an event, simply call ',(0,s.jsx)(n.code,{children:"EventDispatcher#on"})," and ",(0,s.jsx)(n.em,{children:"subscribe"})," for its contents:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"eventDispatcher.on(MessageCreateEvent.class).subscribe(event -> /* do stuff */);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To replicate ",(0,s.jsx)(n.code,{children:"IListener"}),"'s functionality you may use the following example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"interface EventListener<T extends Event> {\r\n    Class<T> getEventType();\r\n    void execute(T event);\r\n}\r\n\r\n// more code ...\r\n\r\nEventListener<MessageCreateEvent> listener = ...\r\neventDispatcher.on(listener.getEventType()).subscribe(listener::execute);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"readyevent",children:"ReadyEvent"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"ReadyEvent"})," in v3 now represents Discord's ",(0,s.jsx)(n.a,{href:"https://discord.com/developers/docs/topics/gateway#ready",children:"ReadyEvent"}),", which is sent before any ",(0,s.jsx)(n.code,{children:"GuildCreateEvent"}),". This is different compared to v2 where ",(0,s.jsx)(n.code,{children:"ReadyEvent"}),' was defined when the bot was "ready", meaning all guilds have been received. In exchange, however, v3 does not require the bot to be "ready" to execute any actions (such as sending a message). This, consequently, also means v3 does not require the bot to be ',(0,s.jsx)(n.em,{children:"logged in"})," to perform actions to Discord."]}),"\n",(0,s.jsxs)(n.p,{children:["To mimic v2's ",(0,s.jsx)(n.code,{children:"ReadyEvent"}),", i.e. know when all guilds have been received, you may use the following example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"discordClient.getEventDispatcher().on(ReadyEvent.class) // Listen for ReadyEvent(s)\r\n    .map(event -> event.getGuilds().size()) // Get how many guilds the bot is in\r\n    .flatMap(size -> client.getEventDispatcher()\r\n        .on(GuildCreateEvent.class) // Listen for GuildCreateEvent(s)\r\n        .take(size) // Take only the first `size` GuildCreateEvent(s) to be received\r\n        .collectList()) // Take all received GuildCreateEvents and make it a List\r\n    .subscribe(events -> /* All guilds received, and client is fully connected */);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"faq",children:"FAQ"}),"\n",(0,s.jsx)(n.h4,{id:"what-is-wrong-with-v2",children:"What is wrong with v2?"}),"\n",(0,s.jsx)(n.p,{children:"Everything. Its problems stem from being the oldest of the 3 major libraries (written before a time the bot API existed) and its developer(s) having inadequate knowledge of Java conventions/practices and lacking OOP concepts."}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:['v2 is a completely blocking API. This means threads must "wait" for actions to be completed before continuing. This wastes a tremendous amount of resources at scale as threads could be accomplishing various other tasks as they "wait" for previous tasks to finish. As noted by ',(0,s.jsx)("a",{href:"/img/blocking_performance.png",target:"_blank",children:"this chart"}),", even wasting a millisecond, in relative terms, is a huge waste of time for a computer, and a typical Discord request is about 50 milliseconds. v3, thanks to Reactor, can maximize the usage of this wasted computing power to utilize less resources to accomplish more tasks."]}),"\n",(0,s.jsx)(n.p,{children:"Of course, you do not have to utilize Reactor's asynchronous features. As previously discussed, blocking with Reactor can be easily accomplished to achieve the previous paradigm."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Channel hierarchy is both wrong and inconsistent. ",(0,s.jsx)(n.code,{children:"IChannel"})," can be represented either by a guild's text channel or a privately messaged channel; meaning methods like ",(0,s.jsx)(n.code,{children:"IChannel#getGuild"})," make no fundamental sense if the type of the channel is private. Should the method return null, or throw an exception? This ambiguity is made worse by the fact ",(0,s.jsx)(n.code,{children:"IVoiceChannel"})," ",(0,s.jsx)(n.em,{children:"extends"})," ",(0,s.jsx)(n.code,{children:"IChannel"}),"; meaning ",(0,s.jsx)(n.code,{children:"IVoiceChannel"})," conceptually represents a guild's text channel, a privately messaged channel, ",(0,s.jsx)(n.em,{children:"and"})," a guild voice channel! Most methods in ",(0,s.jsx)(n.code,{children:"IVoiceChannel"})," throw an exception as they make no sense in the context of an actual voice channel (you cannot send a message in a voice channel, for instance). Additionally, categories ",(0,s.jsx)(n.em,{children:"are"})," channels, but in v2 they are not represented this way via ",(0,s.jsx)(n.code,{children:"ICategory"}),". v3 fixes all these issues with a much better entity hierarchy structure."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"RequestBuffer"}),"/",(0,s.jsx)(n.code,{children:"RequestBuilder"})," were workarounds for rate limiting when it was introduced (yes, v2 was built before rate limiting was a concept for Discord). This makes their usage cumbersome as they ",(0,s.jsx)(n.em,{children:"should"})," be applied to ",(0,s.jsx)(n.em,{children:"every"})," possible request to Discord. This makes knowing when to use them entirely unclear (",(0,s.jsx)(n.em,{children:"which"})," methods, exactly, should either be applied to?), and its existence not balancing its requirement for bot development as a lot of users do not realize these two features exist. v3 fixes this as rate limits will be automatically handled and requests will be executed in order."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["The MessageHistory API is confusing as its construction is spread out across ",(0,s.jsx)(n.em,{children:"15"})," different methods with unexpected, unorthodox, and/or confusing naming and behaviors. Additionally, since ",(0,s.jsx)(n.code,{children:"MessageHistory"})," is a ",(0,s.jsx)(n.code,{children:"List"}),", ",(0,s.jsx)(n.em,{children:"all"}),' messages must be obtained before manipulating them; meaning for very large message histories, it is very likely to reach an OutOfMemoryError when attempting to obtain a history of these channels. v3, in contrast, only has 2 methods to obtain a "message history", with all of the functionality of v2\'s message history being applicable and more. Additionally, because of Reactor, messages can be retrieved on-demand so not all messages have to be loaded in memory before utilizing them for some purpose (like bulk-delete).']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["v2 is riddled with inconsistencies across its API. Some methods return ",(0,s.jsx)(n.code,{children:"null"}),", others throw an exception, while others return ",(0,s.jsx)(n.code,{children:"Optional"}),'. v3 has been heavily focused on staying consistent across its entire API to prevent any unexpected behaviors or lopsided functionality. If something can be "absent", it\'ll return ',(0,s.jsx)(n.code,{children:"Optional"}),". If it can make a request to Discord, it returns either a ",(0,s.jsx)(n.code,{children:"Mono"})," or ",(0,s.jsx)(n.code,{children:"Flux"}),". There are no surprises on what a method may attempt to accomplish or inconsistencies with handling specific cases."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Manipulating entities in v2 is both inefficient and cumbersome. Most entities when being created or edited can set multiple properties at once. For instance, when you create a channel you can set the name, type, position, permission overwrites, etc. all in one request, however, in v2 this is impossible. In order to create/edit with multiple properties you must call individual methods one at a time which makes an entire request to Discord on each and every single invocation. This is tremendously wasteful and quickly makes your bot approach a rate limit. v3 fixes this by utilizing ",(0,s.jsx)(n.a,{href:"/specs",children:"Specs"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:['While it is "possible" to disable the cache in v2, it instantly causes a crash on startup when attempted. v3 was designed with caches being disabled in mind, allowing very lightweight configurations if desired. We have tested v3 running on some of ',(0,s.jsx)(n.a,{href:"https://tatsumaki.xyz/",children:"Tatsumaki"}),"'s shards, and v3 was able to stay under 10 MB of RAM usage. v3's Store API is also far more flexible, allowing other configurations such as off-heap caching to be possible."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["v2 is completely mutable which is susceptible to many race conditions that are incredibly hard to replicate, track down, and/or fix. v3 attempts to be as immutable as possible which has ",(0,s.jsx)(n.a,{href:"https://www.ibm.com/developerworks/library/j-ft4/index.html",children:"numerous benefits"})," for us as a library and you as a user."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["v2 follows some unusual conventions. ",(0,s.jsx)(n.code,{children:"I"})," prefixes for interfaces (which is a C# convention, but not a Java one), as well as a questionable package hierarchy structure (most events are under ",(0,s.jsx)(n.code,{children:"impl"}),", for example). v3's follows proper Java industry conventions, and a package hierarchy that makes intuitive sense."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"where-is-requestbufferrequestbuilder",children:["Where is ",(0,s.jsx)(n.code,{children:"RequestBuffer"}),"/",(0,s.jsx)(n.code,{children:"RequestBuilder"}),"?"]}),"\n",(0,s.jsxs)(n.p,{children:["Classes like ",(0,s.jsx)(n.code,{children:"RequestBuffer"})," and ",(0,s.jsx)(n.code,{children:"RequestBuilder"})," have been completely removed in v3. By default, v3 will execute requests in order and handle rate limits."]}),"\n",(0,s.jsxs)(n.h4,{id:"where-is-messagehistory",children:["Where is ",(0,s.jsx)(n.code,{children:"MessageHistory"}),"?"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"MessageHistory"}),' has been completely removed in v3. A "message history" can be obtained by calling either ',(0,s.jsx)(n.a,{href:"https://www.javadoc.io/doc/com.discord4j/discord4j-core/latest/discord4j/core/object/entity/channel/MessageChannel.html#getMessagesBefore-discord4j.common.util.Snowflake-",children:"MessageChannel#getMessagesBefore"})," or ",(0,s.jsx)(n.a,{href:"https://www.javadoc.io/doc/com.discord4j/discord4j-core/latest/discord4j/core/object/entity/channel/MessageChannel.html#getMessagesAfter-discord4j.common.util.Snowflake-",children:"MessageChannel#getMessagesAfter"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"migration-steps",children:"Migration steps"}),"\n",(0,s.jsx)(n.p,{children:"Important: This section focuses on Discord4J v3.1 rather than v3.0."}),"\n",(0,s.jsx)(n.h3,{id:"client-building",children:"Client building"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The main utility class ",(0,s.jsx)(n.code,{children:"Discord4J"})," was removed. If you used ",(0,s.jsx)(n.code,{children:"Discord4J::enableJettyLogging"})," you should read up on ",(0,s.jsx)(n.a,{href:"/logging",children:"Logging"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DiscordException"})," is not used anymore, and you should attempt to migrate towards reactive ",(0,s.jsx)(n.a,{href:"/error-handling",children:"Error handling"})," or if you decide to block, catch ",(0,s.jsx)(n.code,{children:"RuntimeException"})," or ",(0,s.jsx)(n.code,{children:"ClientException"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["If your login flow consisted in obtaining an ",(0,s.jsx)(n.code,{children:"IDiscordClient"})," instance, you should now either expect ",(0,s.jsx)(n.code,{children:"GatewayDiscordClient"})," or ",(0,s.jsx)(n.code,{children:"DiscordClient"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ClientBuilder"})," is now replaced with ",(0,s.jsx)(n.code,{children:"DiscordClientBuilder"}),". Several options don't exist anymore or have replacements elsewhere. It comes with default options to allow a monolithic multi-shard bot to function. You can start with ",(0,s.jsx)(n.code,{children:"DiscordClient::create"})," or ",(0,s.jsx)(n.code,{children:"DiscordClient::builder"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ClientBuilder::setDaemon"})," does not have an equivalent as it uses Reactor threading. Check the ",(0,s.jsx)(n.a,{href:"/threading",children:"Threading"})," page for more information."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ClientBuilder::withPingTimeout"})," is now called ",(0,s.jsx)(n.code,{children:"setMaxMissedHeartbeatAck"})," and can be set at ",(0,s.jsx)(n.code,{children:"DiscordClient::gateway"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ClientBuilder::setMaxReconnectAttempts"})," now live under ",(0,s.jsx)(n.code,{children:"ReconnectOptions"})," which can be set at ",(0,s.jsx)(n.code,{children:"DiscordClient::gateway"}),". See ",(0,s.jsx)(n.a,{href:"/migrating-from-v3-0-to-v3-1",children:"v3.1 Migration Guide"})]}),"\n",(0,s.jsxs)(n.li,{children:["Shard options like ",(0,s.jsx)(n.code,{children:"ClientBuilder::withShards"}),", ",(0,s.jsx)(n.code,{children:"::setShard"})," and ",(0,s.jsx)(n.code,{children:"::withRecommendedShardCount"})," are present under ",(0,s.jsx)(n.code,{children:"DiscordClient::gateway"}),". See ",(0,s.jsx)(n.a,{href:"/migrating-from-v3-0-to-v3-1",children:"v3.1 Migration Guide"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ClientBuilder"})," cache-related options like ",(0,s.jsx)(n.code,{children:"setMaxMessageCacheCount"})," and ",(0,s.jsx)(n.code,{children:"setCacheProvider"})," now live under the Stores abstraction and can be replaced using a combination of ",(0,s.jsx)(n.code,{children:"MappingStoreService"})," and ",(0,s.jsx)(n.code,{children:"CaffeineStoreService"}),". These options are set under ",(0,s.jsx)(n.code,{children:"DiscordClient::gateway"}),". See also ",(0,s.jsx)(n.a,{href:"https://github.com/Discord4J/Stores/tree/master/caffeine",children:"Stores-Caffeine"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ClientBuilder::registerListener"})," variants are moved to ",(0,s.jsx)(n.code,{children:"GatewayDiscordClient::on"})," method, or ",(0,s.jsx)(n.code,{children:"GatewayDiscordClient::getEventDispatcher"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ClientBuilder::set5xxRetryCount"})," is now abstracted to ",(0,s.jsx)(n.code,{children:"DiscordClientBuilder::onClientResponse"})," where you can set a custom retrying policy. Discord4J retries most 5xx errors by default."]}),"\n",(0,s.jsxs)(n.li,{children:["Event processing options now live under ",(0,s.jsx)(n.code,{children:"EventDispatcher"})," abstraction and can be replaced at ",(0,s.jsx)(n.code,{children:"DiscordClient::gateway"}),", then ",(0,s.jsx)(n.code,{children:"GatewayBootstrap::setEventDispatcher"}),". See ",(0,s.jsx)(n.code,{children:"EventDispatcher"})," class for some built-in factories."]}),"\n",(0,s.jsxs)(n.li,{children:["Setting an initial presence/status is done at ",(0,s.jsx)(n.code,{children:"DiscordClient::gateway"})," then ",(0,s.jsx)(n.code,{children:"GatewayBootstrap::setInitialPresence"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Calling ",(0,s.jsx)(n.code,{children:"DiscordClient::login"})," directly uses all defaults for Gateway. To customize go through ",(0,s.jsx)(n.code,{children:"DiscordClient::gateway"}),", customize the given ",(0,s.jsx)(n.code,{children:"GatewayBootstrap"})," and then call ",(0,s.jsx)(n.code,{children:"GatewayBootstrap::login"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"// v2.10.x\r\nIDiscordClient client = new ClientBuilder()\r\n    .withToken(bot.getToken())\r\n    .setDaemon(bot.isDaemon())\r\n    .withPingTimeout(bot.getMaxMissedPings())\r\n    .setMaxReconnectAttempts(bot.getMaxReconnectAttempts())\r\n    .login();\r\n// v3.1.x\r\nGatewayDiscordClient client = DiscordClient.create(bot.getToken())\r\n    .login()\r\n    .block();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"event-dispatching",children:"Event dispatching"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"GatewayDiscordClient::on"})," to attach a subscriber to receive all events for that type."]}),"\n",(0,s.jsxs)(n.li,{children:["If you relied heavily upon ",(0,s.jsx)(n.code,{children:"@EventSubscriber"})," from v2 you can create an ",(0,s.jsx)(n.a,{href:"https://gist.github.com/quanticc/57ca056ace9c557dc2303ef1e6549253",children:(0,s.jsx)(n.code,{children:"EventSubscriberAdapter"})})," class yourself and use it in the following way:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'GatewayDiscordClient client = DiscordClient.create(token).login().block();\r\nEventSubscriberAdapter adapter = new EventSubscriberAdapter() {\r\n\r\n    @Override\r\n    public void onMessageCreate(MessageCreateEvent event) {\r\n        log.info("> {}", event.getMessage().getContent().orElse(""));\r\n    }\r\n};\r\nclient.on(Event.class)\r\n    .as(adapter::listener)\r\n    .subscribe();\r\n\r\ngateway.onDisconnect().block(); // we should block until it disconnects\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Since ",(0,s.jsx)(n.code,{children:"@EventSubscriber"})," was removed you can use that pattern, overriding the methods you wish to get notified. There is also a reactive alternative ",(0,s.jsx)(n.a,{href:"https://gist.github.com/quanticc/b9c04f16ffdd925b845e3d4851fb10bd",children:(0,s.jsx)(n.code,{children:"ReactiveEventAdapter"})})," you can use similarly."]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["If you previously used ",(0,s.jsx)(n.code,{children:"IListener<E>"})," you can also migrate it to ",(0,s.jsx)(n.code,{children:"EventSubscriberAdapter"})]}),"\n",(0,s.jsxs)(n.li,{children:["Events now live under the ",(0,s.jsx)(n.code,{children:"discord4j.core.event"})," package."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ReconnectSuccessEvent"})," -> ",(0,s.jsx)(n.code,{children:"ReconnectEvent"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ReconnectFailureEvent"})," -> ",(0,s.jsx)(n.code,{children:"ReconnectFailEvent"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DisconnectedEvent"})," has split into ",(0,s.jsx)(n.code,{children:"ReconnectStartEvent"})," and ",(0,s.jsx)(n.code,{children:"DisconnectEvent"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UserBanEvent"})," -> ",(0,s.jsx)(n.code,{children:"BanEvent"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"UserPardonEvent"})," -> ",(0,s.jsx)(n.code,{children:"UnbanEvent"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"MessageReceivedEvent"})," -> ",(0,s.jsx)(n.code,{children:"MessageCreateEvent"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"event-processing",children:"Event processing"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["In general, if an ",(0,s.jsx)(n.code,{children:"Event"})," returns a ",(0,s.jsx)(n.code,{children:"Mono"})," or ",(0,s.jsx)(n.code,{children:"Flux"}),", it means it involves a request that might incur latency and therefore we use Reactor to properly route and schedule that action asynchronously. Such methods are safe to call ",(0,s.jsx)(n.code,{children:"Mono::block"})," or ",(0,s.jsx)(n.code,{children:"Flux::blockLast"})," upon to use the contained type in a blocking way."]}),"\n",(0,s.jsxs)(n.li,{children:["All entities have different names now, but the correlation should be easy to follow, for example: ",(0,s.jsx)(n.code,{children:"IMessage"})," -> ",(0,s.jsx)(n.code,{children:"Message"})]}),"\n",(0,s.jsxs)(n.li,{children:["Checking if a ",(0,s.jsx)(n.code,{children:"MessageChannel"})," is private can be done through ",(0,s.jsx)(n.code,{children:"instanceof PrivateChannel"})," or using ",(0,s.jsx)(n.code,{children:"getType"})," after blocking, or ",(0,s.jsx)(n.code,{children:".ofType(PrivateChannel.class)"})," before blocking."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"DiscordClient::getOurUser"})," -> ",(0,s.jsx)(n.code,{children:"GatewayDiscordClient::getSelf"})," and optionally block"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"working-with-permissions",children:"Working with permissions"}),"\n",(0,s.jsx)(n.p,{children:"Consider the following call:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"boolean hasPermission = message.getChannel().getModifiedPermissions(message.getAuthor())\r\n                    .containsAll(EnumSet.of(Permission.MANAGE_MESSAGES));\n"})}),"\n",(0,s.jsx)(n.p,{children:"To migrate this you should know:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["To work with ",(0,s.jsx)(n.code,{children:"PermissionSet"})," rather than ",(0,s.jsx)(n.code,{children:"EnumSet<Permission>"}),". Build one using ",(0,s.jsx)(n.code,{children:"PermissionSet::of"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Since ",(0,s.jsx)(n.code,{children:"Message::getChannel"})," returns a ",(0,s.jsx)(n.code,{children:"Mono<MessageChannel>"})," and calls like this only make sense under Guild channels, you must ensure first the actual type is ",(0,s.jsx)(n.code,{children:"GuildChannel"}),": ",(0,s.jsx)(n.code,{children:"message.getChannel().ofType(GuildChannel.class)"})]}),"\n",(0,s.jsxs)(n.li,{children:["If you block such a ",(0,s.jsx)(n.code,{children:"Mono"})," and the underlying channel is not a guild one, it will return ",(0,s.jsx)(n.code,{children:"null"}),". There is also ",(0,s.jsx)(n.code,{children:"Mono::blockOptional"})," to get an ",(0,s.jsx)(n.code,{children:"Optional"})]}),"\n",(0,s.jsxs)(n.li,{children:["After blocking, you can then call ",(0,s.jsx)(n.code,{children:"GuildChannel::getEffectivePermissions"})," using the ",(0,s.jsx)(n.code,{children:"Snowflake"})," for a member or role"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The resulting code should look like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"Snowflake authorId = message.getAuthor()\r\n        .map(User::getId)\r\n        .orElseThrow(IllegalArgumentException::new);\r\nboolean hasPermission = message.getChannel().ofType(GuildChannel.class)\r\n        .flatMap(channel -> channel.getEffectivePermissions(authorId))\r\n        .map(set -> set.containsAll(PermissionSet.of(Permission.MANAGE_MESSAGES)))\r\n        .blockOptional()\r\n        .orElse(false);\n"})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var s=i(6540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);